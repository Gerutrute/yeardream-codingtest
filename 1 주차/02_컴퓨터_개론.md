# 1주차 내용 정리

### 목차
1. [컴퓨터 구조](#1-컴퓨터-구조)
2. [운영체제](#2-운영체제)
3. [리눅스 다루기](#3-리눅스-다루기)
4. [네트워크](#4-네트워크)



# 1. 컴퓨터 구조
## 🖥️ 컴퓨터에 대해 알아야 하는 이유
>컴퓨터로 코딩하니까..

운동을 할 때 동작은 따라할 수 있지만 우리 몸에 대해 이해하고 있어야 효과적으로 운동을 할 수 있음

컴퓨터를 몰라도 코딩은 할 수 있겠지만 코드를 효과적으로 작성하기 위해선 컴퓨터의 환경, 작동 방식을 이해하고 있어야 함


### ❓그래도 반드시 알아야 하나?
네. 알아야 합니다.

컴퓨터의 능력은 제한적이고 제한된 환경에서 효율적으로 동작하는 프로그램을 만들어야 함

특히나 DE, DS 라면 대량의 데이터를 효율적으로 처리하고 분석하는 것이 핵심이며 이를 위해선 컴퓨터의 **메모리 구조, 데이터 저장 방식, 알고리즘 최적화** 등등을 이해하는 것이 중요


## ⌨ 컴퓨터 동작 방식
입력(input) ➡️ 처리(process) ➡️ 출력(output)
1. **입력 (input)**
- 입력장치 (키보드, 마우스, 터치스크린, 마이크 등)를 통해 명령어와 데이터 입력

2. **처리 (process)**
- CPU(중앙처리장치)가 입력된 데이터를 연산하고 명령을 실행 -> 사람의 뇌 역활
- RAM(메모리)을 이용해 데이터를 빠르게 저장하고 읽음

3. **출력 (output)**
- 처리된 결과를 모니터, 스피커, 프린터 등을 통해 출력


## ❗데이터와 명령어
컴퓨터는 데이터와 명령어로 동작함

### 🤖기계어(Machine Code)
컴퓨터는 0과 1로 이루어진 기계어만 이해할 수 있음.

- 사람이 직접 기계어를 작성하기 어려우므로, 프로그래밍 언어를 사용하여 더 쉽게 코드를 작성함.

### 어셈블리어(Assembly Language)
기계어와 1:1로 대응되는 저수준 프로그래밍 언어.

- 사람이 이해하기 쉽게 명령어를 문자로 표현한 것.

### 어셈블러(Assembler)
어셈블리어 ➡️ 기계어(바이너리 코드)로 변환하는 프로그램.

- 즉, 사람이 작성한 어셈블리어 코드를 컴퓨터가 이해할 수 있도록 번역하는 역할을 함.


### 📌고급 언어
사람이 이해하기 쉽게 작성된 고수준 프로그래밍 언어

- 마찬가지로 번역 역활을 하는 컴파일러, 인터프리터가 있음


### 컴퓨터 언어
- 컴퓨터는 기계어를 통해 데이터와 명령어를 처리함
- 사람은 기계어를 이용하기 위해 프로그래밍 언어를 사용함

![스크린샷 2025-04-03 104450](https://github.com/user-attachments/assets/37426872-cd5b-4ada-8940-ba0384367fa8)



## 🧠 메모리
데이터를 저장하는 역활

### 🗂️기억장치 종류
1. 레지스터
2. 캐시
3. 주기억장치
4. 보조기억장치

1번으로 갈수록 빠르고 용량이 작으며, 비쌈

### 주기억장치
현재 실행되고 있는 데이터와 명령어를 저장하고 ROM, RAM으로 크게 분류 가능

### ROM과 RAM
|ROM(Read-Only Memory)|RAM(Random Access Memory)|
|---------------------|-------------------------|
|읽기만 가능| 읽기 쓰기가 자유롭게 가능|
|전원이 꺼져도 데이터가 사라지지 않는 비휘발성 메모리|전원이 꺼지면 데이터가 사라지는 휘발성 메모리|
|처리 속도가 느림|처리 속도가 빠름|
|가격이 쌈|가격이 비쌈|

1. **ROM**
- 읽기 전용 메모리
- 컴퓨터를 구종하기 위한 기본적인 데이터 담겨있음
- 전원을 꺼도 데이터 지워지지 않음

- ⭐️ **ROM 종류**
    1. MASK ROM : 제조 공정에서 데이터를 기록하여 데이터 읽기만 가능
    2. PROM : 사용자가 데이터를 한 번 기록 가능
    3. EPROM : 저장되어 있는 데이터를 지우고 쓰기 가능
    4. EEPROM : 전기를 통해 데이터를 지우고 쓰기 가능

2. **RAM**
- 랜덤 액세스 메모리
- 시스템의 단기 데이터 스토리지
- 데이터에 빠르게 액세스 할 수 있도록 컴퓨터가 실시간으로 사용하는 정보 저장
- 많은 애플리케이션을 실행할수록 더 많은 메모리가 필요

- ⭐️ **RAM 종류** 
    1. SRAM : 전원이 공급되는 동안만 내용을 저장
    2. DRAM : 커패시터를 이용해 전하를 축적, 전원이 끊기면 저장된 데이터는 사라짐
    3. SDRAM : 시스템의 클럭 속도와 동기화하여 빠르고 효율적으로 동작

### 데이터 식별
컴퓨터는 메모리에 저장된 데이터를 주소를 참조해서 데이터를 식별함

|주소|데이터|
|----|-----|
|1번지|10110010|
|2번지|01000100|
|...|...|
|...|...|


## 👉CPU
Central Processing Unit, 프로세서(processor)라고도 함, 데이터와 명령어를 처리하는 제어 장치.
클럭과 코엉가 CPU의 성능을 결정함

### ⚡CPU 구성
1. 산술 논리 장치 (Arithmetic and Logical Unit)
2. 레지스터 (Register)
3. 제어 장치 (Control Unit)

### 논리 연산
참과 거짓에 대한 두 가지 값으로 수행하는 연산으로 논리곱(AND), 논리합(OR), 부정(NOT)등이 있음


### 📱산술 논리 연산 장치
**다양한 산술 연산을 계산하는 디지털 회로**

- 논리 회로로 구성된 다양한 **연산 장치**
1. 가산기(Adder) : 덧셈 연산을 수행하는 논리 회로
2. 보수기(Complementor) : 2의 보수를 계산해주는 논리 회로

- **레지스터**
1. 누산기(Accumulator) : 계산 결과가 저장
2. 상태 레지스터(Status Register) : 연산 결과 나오는 오버플로우나 부호, 캐리 등의 상태를 저장
3. 인덱스 레지스터(Index Register) : 데이터가 저장되어 있는 주소 저장


### 🎛제어 장치
> 처리할 명령어를 해독 및 실행하며 CPU의 전체적인 흐름을 제어

### 레지스터
> CPU가 처리할 데이터를 일시적으로 보관하는 기억 장치



## 기타 장치
컴퓨터 구성 장치 중 주기억장치와 CPU 이외에도 입출력 장치와 보조기억장치도 있음

### ⌨️입출력장치
사용자가 원하는 데이터와 명령어를 컴퓨터에 전달하는 입력 장치와 컴퓨터가 사용자에게 결과를 보여주기 위한 출력 장치

#### 예시
- 키보드 : 입력장치
- 마우스 : 입력장치
- 스피커 : 출력장치
- 프린터 : 출력장치

### 📝보조기억장치
전원이 꺼지면 데이터가 사라지는 주기억장치의 단점을 보완한 기억장치.

용량이 크고 주기억장치에 비해 상대적으로 저렴하지만, 속도가 느림

#### 예시
- SSD
- CO-ROM
- USB 플래시 드라이브


## 🚀컴퓨터 동작 흐름
컴퓨터 시스템 내에서 신호를 전송하는 경로 <br> CPU, 메모리, 입출력장치 등 모든 장치는 시스템 버스를 통해 데이터를 주고 받음


### 🛠️시스템 버스 종류
1. 제어 버스 (Control bus) : 제어 신호 전송에 사용
2. 주소 버스 (Address bus) : 메모리나 입출력장치의 주소 전송에 사용
3. 데이터 버스 (Data bus) : 데이터 전송에 사용

#### 예시
|버스 종류|배달 시스템 예시|컴퓨터 시스템 역활|
|---------|--------------|-----------------|
|제어 버스|배달 기사가 "출발하세요!" 명령을 내림|CPU가 "데이터를 저장해!" 같은 명령을 내림|
|주소 버스|배달 주소(서울 강남구 123-4)를 확인|CPU가 "0x1234 메모리 주소에 저장해!" 지정|
|데이터 버스|햄버거를 고객에게 직접 배달|CPU가 실제 데이터(예: 숫자, 문자)를 전송|

### 🔩메인보드
컴퓨터 장치들은 메인보드에 있는 시스템 버스를 통해 서로 연결되어 있음. 다른 말로 마더보드라고도 함

#### 전체 동작 흐름
1. 입력 장치로 데이터와 명령어를 입력 받음
2. CPU에서 레지스터 및 산술 논리 연산 장치를 통해 명령어를 처리
3. 처리된 결과는 메모리에 저장하거나 출력 장치를 통해 출력

### CPU 동작 흐름
Fetch ➡️ Decode ➡️ Execute


# 2. 운영체제
## 💿운영체제 개요
**운영체제(OS, Operating System)**

하드웨어와 소프트웨어를 관리하고 제어하는 소프트웨어

- **하드웨어(HW)**

컴퓨터 시스템에 물리적으로 존재하는 모든 부품

- **소프트웨어(SW)**

사용자의 요구에 따라 컴퓨터 시스템에서 작동하는 프로그램

    1. 응용 소프트웨어 : 특정 작업을 수행하기 위해 설치하는 소프트웨어 (웹 브라우저, 워드, 게임 등)
    2. 시스템 소프트웨어 : 하드웨어와 상호작용하며 컴퓨터 시스템을 관리해주는 소프트웨어 (운영체제, 컴파일러, 인터프리터)

또 다른말로 컴퓨터의 `자원(resource)`을 효율적으로 관리해주는 프로그램

### 🔋자원(resource)
컴퓨터가 동작하기 위해 필요한 모든 것들이며 대표적으로 CPU나 메모리와 같이 컴퓨터 시스템 내에 존재하는 물리적인 부품




## ⭐️ 프로세스와 스레드
### ⚙️프로세스
운영체제에 의해 현재 실행 중인 프로그램, 운영체제로부터 자원을 할당 받아 실행

### 🧵스레드
프로세스 내에서 실행되는 작업의 단위이며 하나의 프로세스는 하나 이상의 스레드로 이루어져 있음

### 설명
실행중인 **프로그램**이 운영체제로부터 메모리와 CPU 같은 자원을 할당받아 동작하면 **프로세스**

**프로세스** 안에 실행되는 작은 작업 단위가 **스레드**

### ✅싱글과 멀티
1. 싱글
- 싱글 프로세스 : 하나의 프로세스만 실행
- 싱글 스레드 : 하나의 작업을 완료할 때까지 다른 작업을 수행하지 않음

2. 멀티
- 멀티 프로세스 : 여러 개의 프로세스가 독립적인 메모리 공간에서 실행
- 멀티 스레드 : 여러 개의 스레드가 동시게 작업을 수행

#### 💡싱글 스레드와 동기
어..? 하나의 작업이 완료될때까지 기다린다?
-> 동기와 같지 않나?

> 싱글 스레드는 기본적으로 동기적으로 작동함. 하지만 비동기 방식으로도 가능함



## 운영체제의 역활
### 메모리 관리
프로그램이 실행될 때 필요한 메모리 공간을 할당하고 관리하는 역활을 함

### 🎭가상 메모리
하지만, 물리적인 메모리는 한정되어 있어 이를 보안하기 위해 가상 메모리 사용

프로그램이 실제로 실행되는 부분만 메모리에 저장하여, 물리적인 메모리의 크기보다 큰 프로그램을 실행할 수 있도록 해줌

- 사용자 입장에서 실제 보다 더 큰 메모리를 사용하는 것처럼 보임

### ✅프로세스 관리
실행중인 프로그램을 효율적으로 관리하기 위해 프로세스 스케줄링을 수행하며, 이를 통해 각 프로그램이 CPU를 사용할 수 있도록 조정

> 💡 프로세스 스케줄링 : 프로세스가 실행되는 순서를 관리


### ✅멀티태스킹
 이러한 프로세스 스케줄링을 통해 여러 개의 작업을 동시에 실행하는 멀티태스킹이 가능해짐. 
 
 즉, 사용자는 여러 프로그램을 동시에 실행하면서도 각각이 원활하게 동작하는 것처럼 느낄 수 있음.

### 🖥️운영체제의 역활들
1. 네트워크 자원에 대한 관리 ⚙️
2. 파일과 디렉토리를 생성, 복사, 삭제하는 파일 시스템 관리 📂
3. 입출력 장치의 관리를 통한 입출력 작업 🔁
4. 사용자 인증, 방화벽 등 보안 및 인증 🎯


## 커널과 셸
### ✅커널(Kernel)
하드웨어와 소프트웨어의 인터페이스이고 프로세스 스케줄링, 메모리 관리, 입출력 제어 등 핵심 기능 담당함
(ex. Linux, Minix)

- 두 개의 프로세스가 동시에 자원에 접근했을 때 발생할 수 있는 문제(동기화 문제)를 관리해줌

### ✅셸(Shell)
커널과 사용자간의 인터페이스이고 사용자가 입력한 명령어를 해석하여 커널에 전달하고 커널이 실행한 결과는 사용자에게 출력
(ex. Ternimal, PowerShell, Bash, Zsh, CMD)



## 🧾리눅스
먼저 운영체제를 배워야 하는 이유. 개발자는 프로세스와 메모리를 이용하는 프로그램을 만드는 사람이기 때문

### ✅장점
1. 오픈 소스로 코드를 무료 공개하고 있어 코드에 대한 접근이 자유로움
2. 리눅스 기반으로 배포된 다른 여러 운영체제들이 많음 (ex. Ubuntu)
3. 안정적인 운영체제로 개발 서버로 사용되는 비중이 높음 (AWS EC2, Google Cloud, Azure 모두 리눅스 기반)
4. 많은 개발자 도구와 환경을 제공해줌 (Bash, Zsh, Python, Docker, Jupyter...)



## ⚙️리눅스 환경 설정
- **GUI**

Graphic User Interface, 사용자가 편리하게 사용할 수 있도록 입출력 등의 기능을 알기 쉬운 아이콘과 같은 그래픽으로 나타냄

- **CLI**

Command Line Interface, 터미널에서 명령어를 사용하여 컴퓨터 시스템과 상호작용 하는 방식


리눅스는 GUI, CLI 모두 지원, 기본적으로 CLI통해서 작업 수행

### 💻Mac
- Command + space > 터미널 > Enter

### 🖥Windows
- CMD, PowerShell, Windows Terminal에서는 리눅스 명령어 사용하지 못함
-> WSL 이용해 Ubuntu 설치해야 함

# 3. 리눅스 다루기
## 🐧리눅스 기본 명령어 1 ⭐️ 
1. **pwd** : 현재 작업중인 디렉터리의 경로를 출력

![스크린샷 2025-04-03 152030](https://github.com/user-attachments/assets/f15c890f-138e-41f2-8f43-5a79764c069e)


2. **ls** : 현재 디렉터리에 있는 파일과 폴더 목록을 출력

![스크린샷 2025-04-03 152149](https://github.com/user-attachments/assets/a666b9e6-cd6f-4d3a-aec9-3cb86a23b25b)


3. **mkdir** [이름] : 새로운 디렉터리 생성

![스크린샷 2025-04-03 152234](https://github.com/user-attachments/assets/9b92ab65-c29e-45be-9656-71170ce67305)


4. **cd** [경로] : 해당 경로로 이동

![스크린샷 2025-04-03 152314](https://github.com/user-attachments/assets/9a8ddeba-b696-4771-b7bc-b8e2a3cfdfe2)


5. **절대 경로**와 **상대 경로**
- 절대 경로 : '/'로 시작하는 루트 디렉터리부터 시작하는 전체 디렉터리 경로를 나타냄
- 상대 경로 : 현재 작업 디렉터리를 기준으로 상대적인 위치를 지정
- '..'은 현재 경로의 상위 디렉터리를 가리키고, '.'은 현재 디렉터리를 가리킴


6. 명령어 옵션
- **'-a'** : 숨김 파일을 포함하여 모든 파일과 디렉터리를 출력

![스크린샷 2025-04-03 152442](https://github.com/user-attachments/assets/b90665ac-621d-4210-aa42-5b0e7e8afdcc)

- **'-l'** : 파일과 디렉터리의 상세 정보를 출력

![스크린샷 2025-04-03 152513](https://github.com/user-attachments/assets/917cc0d5-8de7-4a82-a0ec-145dbdc09f8c)

- **'-al'** : 이와 같이 묶어서 사용도 가능

![스크린샷 2025-04-03 152540](https://github.com/user-attachments/assets/07235ea4-fc72-48c1-9240-6bc973d125f2)

- **'-t'** : 파일 수정시간 순으로 정렬하여 출력

![스크린샷 2025-04-03 152612](https://github.com/user-attachments/assets/f7629620-cf5d-490e-8b6d-7cfd9a99d53d)

- **'-r'** : 파일 수정시간 역순으로 정렬하여 출력

![스크린샷 2025-04-03 152628](https://github.com/user-attachments/assets/50d936ca-90ca-4125-a7d5-9c9b70f64d65)

- **'-R'** : 하위 디렉터리를 포함하여 전체 파일 목록 출력

![스크린샷 2025-04-03 152656](https://github.com/user-attachments/assets/7f53c585-cb46-4936-858c-a3c6252dba48)

- **'-S'** : 파일 크기 순서대로 정렬하여 출력

![스크린샷 2025-04-03 152725](https://github.com/user-attachments/assets/f52fd9bf-5671-4bb5-9f12-9297f8772f07)

7. **alias** : **'ll'** 명령어로 자세한 파일 리스트를 확인할 수도 있고 이는 'alias ll-'ls -lh'로 정의한 것임

![스크린샷 2025-04-03 152741](https://github.com/user-attachments/assets/6bfb3c87-cd8f-4a36-a068-19b0a728ba74)




## 🐧리눅스 기본 명령어 2
1. `touch [이름]` : 새로운 파일 생성



2. `mv [이름] [경로]` : 파일이나 디렉터리르 이동하거나 이름 변경



3. `cp [이름] [경로]` : 파일이나 디렉터리 복사
- 디렉터리 복사는 '**cp -r**', '-r'은 recursive 라는 뜻으로 하위 디렉터리 모두 적용한다는 의미



4. `rm [이름]` : 이름이나 디렉터리 삭제
- -r : **recursive**
- -f : **force** 권한이 없는 파일도 강제로 삭제



## 🔀리다이렉션
### 📢표준 스트림
컴퓨터 프로그램과 그 외부에 연결된 입출력 통로

### 정의
방향을 바꾼다는 뜻으로 표준 입력/출력의 흐름을 변경하는 
기능을 의미하는데 기본적으로 터미널에 출력되는 데이터를 
파일로 저장하거나 다른 명령어로 전달할 수 있음

- `cat` : 파일의 내용을 출력
```Bash
cat test.txt

> hello
```

- hello라는 문자를 test.txt에 입력


### 응용
'`ls -al > file-list.txt`'로 파일 목록(ls -al 내용)을 새로운 파일에 저장할 수 있음


### 💡출력 리다이렉션
- **'>'** : 기존 파일을 덮어 씀
- **'>>'** : 기존 파일에 내용을 추가함

```Bash
echo "hello" > test.txt   # test.txt에 "hello"를 입력 (덮어쓰기)
echo "world" >> test.txt  # test.txt에 "world" 추가 (덮어쓰기 X)

```



### 💡입력 리다이렉션
- **'<'** : 파일에서 데이터를 읽어서 명령어의 입력으로 사용
- **'<<'** : 여러줄의 입력을 명령어에 전달

```Bash
sort < test.txt  # test.txt의 내용을 정렬하여 출력
cat << EOF > test.txt
hello
world
EOF # 여러 줄을 test.txt에 EOF 나올때까지 입력 받아 test.txt에 저장
```



## 📝문서 편집기
### vi [이름] (Vim)
키보드만으로 파일을 편집할 수 있는 터미널 기반 에디터이며 파일 내용을 변경하거나 저장하는 작업을 수행하는 명령 모드와 텍스트를 입력하는 입력 모드가 있음

(여담으로 vim 전용 키보드 키캡도 존재하기도 함)
![vim 키캡](https://ae01.alicdn.com/kf/Ac03c6aaf1e1a482698d40eb5258d8520g.jpg)


### 추가 명령어
- 'i' : 현재 커서 위치에 문자를 삽입하면 입력 모드로 전환
- 'a' : 현재 커서 다음에 문자를 삽입하며 입력 모드로 전환
- 'o' : 현재 행 다음에 새로운 행을 만들고, 문자를 삽입하며 입력 모드로 전환
- 'x' : 현재 커서 위치의 문자를 삭제
- 'dd' : 현재 커서가 위치한 행을 삭제
- ':w' : 파일을 저장
- ':q' : vi를 종료
- ':q!' : 변경 사항 저장하지 않고 vi 강제 종료
- ':wq' : 파일을 저장하고 vi를 종료
- 'ESC' : 입력 모드를 종료하고 명령 모드로 전환


### 입력 모드와 명령 모드
- 입력모드 : 'i'를 누르면 키보드를 이용해 파일 내의 입력 가능
- 명령모드 : 'ESC'를 누르면 파일 저장, 종료하는 등의 명령어 입력 가능



## 🔗파이프
한 프로세스의 출력을 다른 프로세스의 입력으로 연결함으로써, 두 개 이상의 명령어를 조합하여 복잡한 작업을 수행할 수 있음


- grep [문자] [파일] : 파일에서 원하는 문자를 검색
```Bash
grep he test.txt

> hello
```

### vertical bar(|) - 파이프
두 명령어를 연결할 수 있고 파이프를 이용해 파일 및 디렉터리 목록에서 특정 문자를 포함한 파일과 디렉터리를 찾을 수 있음

```Bash
ls | grep test

> test.txt test2.txt
```

### &&
명령어를 순차적으로 실행하는 방법

```Bash
echo hello > test3.txt && cat test3.txt

> hello
```
`echo hello > test3.txt` 를 통해 "hello"가 저장된 test3.txt 파일 생성
-> `cat` 명령어로 파일 내용 출력


### ;
';'는 앞의 명령어가 성공적으로 실행되지 않아도 뒤에 것이 실행됨

### &
'&'는 프로세스를 백그라운드에서 실행

- 백그라운드란 사용자의 입력과 출력으로부터 독립적으로 실행되는 경우 <-> 포어그라운드 (백 <-> 포어)


## ⚙️프로세스
1. `ps` : 현재 실행중인 프로세스의 정보를 출력

![스크린샷 2025-04-03 175837](https://github.com/user-attachments/assets/9055e4ed-83f4-4477-a7bb-ea8bcd121089)

2. `ps aux` : 모든 프로세스의 세부적인 정보를 출력하고 파이프를 이용해 찾고 싶은 프로세스의 PID를 찾아낼 수 있음

![스크린샷 2025-04-03 175947](https://github.com/user-attachments/assets/7c76749e-bc53-43bd-b4f2-7ea577e9fec9)

3. `kill -9 [PID]` : PID로 해당 프로세스를 강제로 종료할 수 있음

![스크린샷 2025-04-04 140804](https://github.com/user-attachments/assets/7a954aa6-e2f8-4972-8a8f-7023cc3de7b5)


4. `Ctrl + C` : 복사가 아님. 프로세스 종료
> Ctrl + C

5. `Ctrl + Z` : 뒤로 돌아가기가 아님. 프로세스 정지. `fg % 1`을 입력해 다시 실행 가능
> Ctrl + Z



## 마운트
### 📦마운트 (Mount)
파일 시스템의 일부를 다른 디렉터리에 연결하는 것을 말함.
다른 매체의 파일 시스템을 사용할 때 사용하며, 이를 통해 파일 공유가 가능


### 명령어 'mount'
현재 시스템에 마운트 된 정보를 출력


#### sudo
super user(관리자)의 보안 권한으로 프로그램을 구동할 수 있도록 하는 명령어


### df
디스크의 용량을 출력하고 `-h` 옵션을 붙여서 사용하면 디스크 용량에 단위를 붙여서 출력


### du
디렉터리 내의 파일 및 디렉터리의 용량을 출력하고 `-h` 옵션을 사용하면 디스크 용량에 단위를 붙여서 출력


### 심볼릭 링크
원본 파일이나 디렉터리를 참조하는 링크를 연결해둔 것이고 `ln -s [원본이름] [링크이름]`을 이용해서 심볼릭 링크를 생성할 수 있음



# 4. 네트워크

## 🌐네트워크와 인터넷
### 네트워크
서로 다른 기기(컴퓨터)가 통신하기 위해 유선 혹은 무선으로 연결되어 있는 것


- 모든 컴퓨터가 하나씩 연결 X -> 네트워크 장치 통해 연결 (ex.라우터)

> 🔔라우터 : 여러 대의 컴퓨터나 기기를 연결하여 네트워크를 구성하거나, 여러 네트워크 간의 중계 역활을 하는 장치

### 인터넷
여러 네트워크가 서로 연결되는 것


### IP 주소 (Internet Protocol address)
인터넷에서 IP 주소를 통해 서로를 식별 ex)192.168.123.132

**IP 확인 방법**
> 리눅스, Mac -> 터미널 명령어 `ifconfig`

> 윈도우 -> 터미널 명령어 `ipconfig`


## 🔢PORT
### 포트(PORT) 번호
네트워크에서 컴퓨터나 기기의 특정 애플리케이션이나 서비스에 연결할 수 있도록 식별하는 번호

> 127.0.0.1:3000 -> 에서 3000과 같은 번호

- 포트 번호는 IP 주소 뒤에 콜론(:)으로 구분하여 나타냄

- 사용 중인 포트는 중복해서 사용할 수 없음
    - 중복해서 사용할 경우 'port already in use 3000' 과 같은 에러가 뜸
    - 해당 에러르 해결하는 방법으로는 다른 포트 번호 이용, 기존 포트 번호 종료가 있음


### 명령어
> netstat -> 터미널에서 포트 번호를 확인하는 명령어


### 흔히 쓰이는 포트
|포트 번호|용도|
|--------|-----|
|21|FTP (File Transfer Protocol)|
|22|SSH (Secure Shell)|
|23|TELNET|
|25|SMTP (Simple Mail Transfer Protocol)|
|53|DNS (Domain Name System)|
|80|HTTP (HyperText Transfer Protocol)|
|443|HTTPS (HTTP의 보안이 강화된 버전)|

익숙한 용어들이 많이 보이죠?

포트 번호는 0 ~ 65535까지 사용이 가능하지만 0 ~ 1024번은 통신 규약에 따라 이미 정해져 있음


## 🌍DNS
### 도메인
IP 주소는 외우기가 어려워요. 네이버의 IP 주소를 알고 계시나요? 
저희가 알고 있는건 `www.naver.com` 이죠.

이걸 `도메인`이라고 합니다.

IP 주소 대신 기억하기 쉬운 도메인을 사용하는데 이는 고유한 주소입니다.

### DNS (Domain Name System)
도메인의 이름과 IP 주소간의 변환을 처리해주는데 네이버의 `www.naver.com` 이라는 도메인과 IP 주소를 서로 찾아주는 역할을 하며, 
우리가 입력한 도메인을 실제 서버의 위치로 안내해줍니다.


### ⚙️DNS 동작 과정
웹 브라우저에 입력된 도메인 이름을 DNS 서버에서 실제 주소로 변환해주고 실제 주소를 입력하면 웹 화면을 띄워줍니다.

1. 웹 브라우저 도메인 이름 입력 : `www.naver.com`
    - 입력받은 도메인 주소 DNS로 보냄

2. DNS 서버 : (실제 IP 주소 반환) `125.209.222.141`
    - 받은 도메인 주소를 IP 주소로 변환해서 다시 보냄

3. 웹 서버 : 네이버 창 띄움움
    - 웹 브라우저에서 받은 IP 주소를 웹 서버에 요청하여 브라우저에 반환

> :bell: 최상위 도메인 (Top-level domain, TLD) : 도메인 이름의 가장 오른쪽 부분으로 국가 코드나 일단 형태로 구성이 된다.
(ex. co.kr)



## 🧑‍💻서버와 클라이언트
### 서버
다른 컴퓨터나 디바이스에서 요청하는 데이터나 서비스로 응답하는 컴퓨터 시스템입니다.

> 흔히 말해 "아 서버 터졌어!" 할때의 그 서버 맞습니다.

### 클라이언트 (Client)
다른 컴퓨터나 디바이스에 있는 데이터나 서비스를 요청하는 시스템입니다.

> 크롬 브라우저가 클라이언트가 됩니다.

### 📤서버와 클라이언트 관계📥
클라이언트 (크롬)가 서버에 요청을 하면, 서버는 그 요청을 처리하고 결과를 클라이언트에게 반환하는 형태로 작동하고, 
서비스를 다른 클라이언트가 접근할 수 있도록 게시하는 것을 `호스팅`이라고도 합니다.

> :point_up: 예를 들어, 쇼핑몰을 예시로 들어볼게요.

1. "클라이언트"인 크롬이 "상품 목록 보여줘!" 라고 상품 목록 버튼을 클릭
2. "서버"는 상품 정보를 찾아서 브라우저에 전달하여 우리가 볼 수 있어요.
3. 이때, 쇼핑몰 사이트가 누구나 접속할 수있도록 인터넷에 올라가 있는 상태가 바로 `호스팅`이에요!


❗️결국 서버도 컴퓨터와 같아요.


## TCP/UDP
### 프로토콜 (Protocol)
지금까지 프로토콜의 종류가 많이 나왔었죠?
이 프로토콜이란건 네트워크에서 서로의 컴퓨터가 원활한 인터넷 통신을 하기 위한 규칙이에요!

프로토콜중에서도 많은 종류가 있지만 전송 목적의 프로토콜이 있어요.

### TCP(Transmission Control Protocol)
신뢰성 있는 데이터 전송을 지원하는 연결 지향형 프로토콜이고, 패킷의 손실을 검사하고 순서가 바뀌지 않도록 보장해주는 프로토콜이에요

> :bulb: 패킷이란? 네트워크에서 데이터를 전송하는 단위에요.

무슨 이유 때문에 신뢰성 있는 데이터 전송이 가능하냐?

### 3-Way Handshake
바로 이 과정을 통해서 검증이 가능한데, 클라이언트와 서버간의 패킷을 총 3번 주고받으면서 서로 통신이 가능한지
준비가 되었는지 확인하는 과정이에요.

용어가 어려워 보이지만 사실 알고보면 별거 아니에요.

🎯 **순서 정리**
1. 클라이언트 → 서버: SYN

    - "나 통신할래~ 준비됐어?"

2. 서버 → 클라이언트: SYN + ACK

    - "오케이 나도 준비됐고, 너 요청도 잘 받았어!"

3. 클라이언트 → 서버: ACK

    - "좋아! 이제 본격적으로 데이터 주고받자!"


- SYN : 연결 요청 신호
- ACK : 상대방 패킷에 대해 응답 역활


### 4-Way Handshake
그리고 4번의 과정을 거치는 4-Way Handshake도 있어요.
이 과정은 연결 종료할 때 사용되는데 송수신을 양쪽 모두 따로 종료를 해야해서 한 번의 과정이 추가가 된거에요.

🎯 순서 정리
1. 클라이언트 → 서버 : FIN
→ "나 이제 데이터 안 보낼게!"

2. 서버 → 클라이언트 : ACK
→ "오케이, 너가 데이터 안 보낸다는 거 확인했어!"

3. 서버 → 클라이언트 : FIN
→ "나도 이제 데이터 안 보낼게!"

4. 클라이언트 → 서버 : ACK
→ "좋아! 나도 확인했어!"

:bulb: FIN = Finish 패킷



### UDP (User Datagram Protocol)
TCP와는 성격이 다른 UDP는 신호 절차 없이 일반적으로 데이터를 전달하는 비연결형 프로토콜이에요.
그러다보니 신뢰성은 낮아지지만 속도는 빨라요!

### 📍대체로 어디에?
그럼 대체로 어떤 방면에서 많이 쓰일까요.
보통 속도가 중요한 곳에 많이 쓰이는데

|예시|이유|
|---|----|
|🎮게임|실시간 반응이 중요!|
|📺실시간 스트리밍|약간 끊김 보단 실시간이 중요!|
|📞화상/음성 통화|지연 없는 음성이 핵심!|


### 🆚TCP vs UDP 최종 정리
|항목|TCP|UDP|
|---|----|---|
|연결방식|연결지향|비연결|
|신뢰성|높음|낮음|
|속도|느림|빠름|
|사용처|웹, 파일전송|게임, 스트리밍|


## ✅HTTP
### 📦HTTP (Hypertext Transfer Protocol)
웹 브라우저와 웹 서버 간의 통신에서 HTML문서, 이미지, 오디오, 비디오 등 리소스를 전송하기 위해 사용되는 규칙이에요.

### ✉️HTTP 메시지
클라이언트는 HTTP 요청 메시지를 서버에 전송하고, 서버는 HTTP 응답 메시지를 클라이언트에 반환합니다.

### ✅특징
:one: 무상태 (Stateless)
- 서로 기억 안 함
→ 이전에 어떤 데이터를 주고받았는지 기억하지 않음

- 요청만 받고 끝
→ "요청 받았다! 보냈다!" 그걸로 끝. 이후는 신경 안 씀.

- 단순하고 빠름
→ 상태 저장 안 하니까 리소스 적게 사용 + 처리 빠름


:two: 비연결성 (Connectionless)
- 바로 쏜다!
→ TCP처럼 “먼저 연결합시다” 안 함. 그냥 바로 데이터 전송!

- 상대가 없어도 전송 가능
→ 받는 쪽이 준비 안 돼 있어도 그냥 보냄. (받든 말든 상관 없음)

- 속도 빠름
→ 연결 과정 없으니까 지연 시간 없이 빠름


### ✅HTTPS (Hypertext Transfer Protocol Secure)
기존의 HTTP에서 뒤에 Secure 가 붙었으니 보안을 강화한 프로토콜이에요.

기본적으로 HTTP는 포트 번호 80을 사용하지만, HTTPS는 443을 사용합니다.




## HTTP 메시지
### 📐HTTP 구조
1. Start Line
2. Header
3. Blank Line -> 헤더와 본문을 식별합니다.
4. Body -> 전송할 데이터가 담겨 있어요.

순으로 위에서 아래로 구성이 되어있는데 요청 메시지와 응답 메시지에 따라 담기는 내용의 차이가 있어요.
먼저 `요청 메시지`를 보면 아래와 같아요.

### 🚦Start Line (요청 메시지)
- HTTP Method : 요청의 의도 (GET, POST, PUT, DELETE)
- Request target : 요청하는 대상의 URL
- HTTP version : HTTP 프로토콜 버전

이 내용들이 합쳐져서 아래와 같이 표현됩니다.
#### 예시
> GET /index.html HTTP/1.1


#### 형식
> [HTTP Method] [Request target] [HTTP version]


### Header (요청 메시지)
다양한 종류가 있는데 Host, User-agent, Referer, Accept, If-Modified-Since, Authorization, Origin, Cookie 등등이 있어요

| Header 이름          | 쉽게 말하면            | 설명                                                             |
|----------------------|-------------------------|------------------------------------------------------------------|
| **Host**             | 📍어디로 보낼까?        | 요청을 보낼 **도메인 주소** (ex. `www.example.com`)             |
| **User-Agent**       | 🧑‍💻누가 보냈는지        | 사용자의 **브라우저, 운영체제 정보** (ex. 크롬, 사파리 등)     |
| **Referer**          | 🔗어디서 왔는지          | 이 페이지에 **접속하기 전**에 보고 있던 URL                      |
| **Accept**           | 📦뭘 받을 수 있는지      | 브라우저가 **받을 수 있는 데이터 타입** (ex. JSON, HTML 등)     |
| **If-Modified-Since**| 📅바뀐 게 있는지 확인   | 마지막 요청 이후 **내용이 바뀌었는지** 확인하려는 조건           |
| **Authorization**    | 🔐내가 누군지 인증       | 로그인 정보나 **토큰** 등을 담아서 인증하는 용도                |
| **Origin**           | 🌍요청의 출처            | 요청을 보낸 **도메인 주소** (보안, CORS 관련)                   |
| **Cookie**           | 🍪사용자 정보 저장       | 사용자 정보를 **브라우저에 저장해서** 같이 보냄 (로그인 상태 등)|


이제 `응답 메시지`를 볼까요

### 🚦Start Line (응답 메시지)
- HTTP version : 서버가 사용하는 HTTP 버전 (예: HTTP/1.1)
- Status Code : 요청에 대한 처리 결과 숫자 (예: 200, 404, 500 등)
- Reason Phrase : 상태 코드에 대한 간단한 설명 (예: OK, Not Found)

#### 예시
> HTTP/1.1 200 OK

#### 형식
> [HTTP version] [Status Code] [Reason Phrase]


### Header (응답 메시지)
아래는 서버가 응답 메시지에 자주 포함하는 헤더들이에요


| Header 이름         | 쉽게 말하면            | 설명                                                               |
|---------------------|-------------------------|--------------------------------------------------------------------|
| **Content-Type**    | 🧾무슨 자료야?          | 응답 본문의 **데이터 타입** (ex. `text/html`, `application/json`) |
| **Content-Length**  | 📏얼마나 길어?          | 본문 데이터의 **길이 (바이트 수)**                                 |
| **Set-Cookie**      | 🍪이거 저장해줘         | 브라우저에 **새 쿠키를 저장**하라고 지시함                         |
| **Cache-Control**   | 🗃️이거 저장해도 돼?     | 응답 데이터의 **캐싱 정책**을 지정함                              |
| **Location**        | 📍여기로 가세요          | 리다이렉트 시 **새로운 URL** 지정 (예: `301`, `302` 응답 시 사용)  |
| **WWW-Authenticate**| 🔐인증해 주세요          | 인증이 필요한 경우 **어떻게 인증해야 하는지** 알려줌              |
| **Access-Control-Allow-Origin** | 🌐접근 허용 도메인 | CORS 요청에 대해 **어느 출처에서 접근 가능한지** 명시              |



## 기타 프로토콜 
### 📧 SMTP (Simple Mail Transfer Protocol)
전자 메일을 보낼 때 사용하는 프로토콜이에요.

- 역할: 사용자가 작성한 이메일을 메일 서버에 전달 → 수신자의 메일 서버로 전송

- 예시: Gmail에서 메일을 보내면, SMTP가 메일을 상대방의 메일 서버로 전달해요.

### 📁 FTP (File Transfer Protocol)
서버와 클라이언트 간에 파일을 주고받을 수 있는 프로토콜이에요.

- 역할: 서버와 연결 후 파일 업로드/다운로드

- 특징: 3-Way Handshake 사용, 대용량 전송에 유리하지만 요즘은 보안 문제로 덜 사용돼요.

- 예시: 웹 서버에 웹사이트 파일을 올릴 때 FTP 클라이언트를 이용해 전송해요.


### 🔒 SSH (Secure Shell)
서버에 원격으로 접속하고 명령을 실행하거나 파일을 전송할 수 있게 해주는 보안 접속 프로토콜이에요.

- 역할: 서버에 안전하게 로그인해서 제어하거나 파일 전송

- 특징: 모든 데이터는 암호화되어 전송돼요.

- 예시: ssh user@192.168.0.1 명령으로 원격 서버에 접속해요.

### 기타 프로토콜
| 프로토콜 | 설명 | 주요 용도 |
|----------|------|-----------|
| **DHCP** | IP 주소를 자동으로 할당하는 프로토콜 | 네트워크 연결 시 자동으로 IP 부여 |
| **POP3** | 메일을 **받는** 프로토콜 (다운로드 후 삭제) | 이메일 수신 (오프라인용) |
| **IMAP** | 메일을 **받는** 프로토콜 (서버에 보관) | 여러 기기에서 이메일 동기화 |
| **SNMP** | 네트워크 장비를 모니터링하는 프로토콜 | 라우터, 스위치 등 관리 |




## 보안
### 🔒SSL (Secure Sockets Layer)
클라이언트와 서버 간에 전송되는 데이터를 암호화하여 통신을 보호하고 보안을 유지하기 위해 사용되는 프로토콜이에요.

> 예시: 인터넷 쇼핑몰에서 결제 정보를 입력할 때, 정보가 암호화되어 전송돼요.

### 🔐TSL (Transport Layer Security)
SSL과 동일한 기능을 하면서 보안성이 더욱 강화되었고 웹 브라우저와 서버 간의 통신, 이메일 및 파일 전송 등 다양한 곳에서 사용돼요.

> 예시: 주소창에 자물쇠 🔒 아이콘이 뜨는 https 사이트들은 TLS를 사용해요.

### 🙋인증 및 인가
보안적인 측면에서 사용자가 누구인지 확인하는 인증과 사용자가 접근할 수있는 자원에 대한 권한을 부여하는 인가가 중요해요

- 인증: "너 누구야?" → 사용자의 신원을 확인
- 인가: "너 이거 해도 돼?" → 사용자에게 권한을 부여
- 예시: 로그인 후 일반 회원은 게시글을 볼 수만 있고, 관리자는 수정/삭제도 할 수 있어요.

### 🍪쿠키 (Cookie)
서버에 의해 클라이언트에 저장되는 데이터 파일이에요.
서버의 부하가 줄어들지만, 탈취되면 개인정보가 노출될 수 있음

- 개발자 도구 `F12` -> Application -> 'Storage' 쿠키가 저장되어 있어요.

> 예시: 🍪 쿠키 부스러기처럼, 웹사이트 방문 기록이 브라우저에 남아 있는 느낌이에요.

### 📦세션 (Session)
클라이언트의 상태 정보를 서버 측에서 유지합니다.
보안성은 높지만 서버에 많은 자원이 필요하기 때문에 부하가 걸릴 수 있음

> 예시: 쇼핑몰 장바구니에 담긴 제품 정보가 서버에 저장되어 있어요.


### 🍪쿠키와 📦세션
웹에서 사용자의 정보를 어딘가에는 저장해야 하는데 HTTP는 상태를 저장하지 않음
쿠키는 클라이언트에 사용자의 정보를 저장하는 방식이고 세션은 서버에 저장하는 방식임

- 쿠키: 클라이언트에 저장, 서버 부하 적음, 보안 약함
- 세션: 서버에 저장, 보안 좋음, 서버 부하 있음
- 예시: 쿠키는 사용자가 갖고 있는 메모장, 세션은 서버의 메모장에 기록된 내용이라고 생각하면 돼요.


### 🪪JWT (Json Web Token)
웹의 사용자 인증 정보를 안전하게 관리하기 위한 토큰이고 
Header, Payload, Signature 라는 데이터들을 인코딩한 형태로 저장합니다.

> 예시: 영화관 티켓처럼, 정보가 들어 있고 유효하면 입장할 수 있어요.

### ✅쓰는 이유
- 서버가 상태를 저장하지 않아도 되니까 부담이 줄고
- 서명(Signature)을 통해 변조를 방지
- 만료 시간 설정으로 보안성도 확보돼요
