# 1주차 내용 정리

### 목차
1. [리눅스의 세계로](#1-리눅스의-세계로)
2. [리눅스 파일 시스템](#2-리눅스-파일-시스템)
3. [알고 쓰는 리눅스 명령어](#3-알고-쓰는-리눅스-명령어)
4. [프로세스와 네트워크](#4-프로세스와-네트워크)


# 1. 리눅스의 세계로
## 🌟리눅스 소개
### 🐧리눅스란?
리눅스는 리누스 토발즈 (Linus Torvalds) 가 만든 컴퓨터 운영체제에요.

- 오픈 소스이며 누구나 자유롭게 수정하고 배포할 수 있어요.
- 대표적인 자유 소프트웨어로, 많은 서버와 시스템에서 사용되고 있어요.

> 🔧 예시: 우리가 접속하는 많은 웹사이트들도 사실 백그라운드에서 리눅스로 돌아가고 있어요!

## 🛠️리눅스의 특징 및 종류
- 유닉스 기반으로 만들어졌어요.
- 멀티 유저: 여러 사용자가 동시에 사용 가능
- 멀티 태스킹: 여러 작업을 동시에 처리할 수 있어요
- CLI + GUI 지원: 명령어 기반 환경도, 그래픽 환경도 모두 사용 가능
- 강력한 네트워크 기능: 서버 운영에 최적화되어 있어요

>🧑‍💻 예시: 개발자나 서버 관리자는 CLI(터미널)로 리눅스를 조작하는 걸 더 선호해요!

- **배포판 종류**

| 배포판 | 특징 |
|--------|------|
| **Ubuntu** | 초보자도 쓰기 쉬운 데스크탑용 배포판 |
| **CentOS / RHEL** | 서버 운영에 자주 사용되는 안정적인 배포판 |
| **Debian** | 우분투의 기반이 되는 배포판, 패키지 관리가 안정적 |
| **Fedora** | 최신 기술을 빠르게 적용하는 배포판 |
| **Arch Linux** | 고급 사용자를 위한 최소 구성 중심의 배포판 |

- **리눅스의 종류**

| 계열      | 대표 운영체제       | 특징 |
|-----------|--------------------|------|
| **Red Hat** | Red Hat Enterprise Linux (RHEL), CentOS, Fedora | 기업용 서버 환경에 최적화, .rpm 패키지 사용 |
| **Debian** | Debian, Ubuntu     | 안정성과 패키지 관리가 뛰어남, .deb 패키지 사용 |
| 기타/모바일  | Android            | 리눅스 커널 기반, 모바일 운영체제 |


- **활용 분야**
네트워크 서버 장비, 라즈베리파이, 리눅스 개발 서버, 안드로이드, 개인 PC 블랙박스, TV 셋톱박스, 정밀 의료기기



## 🛠️우분투
데비안 GNU/Linux를 기반으로 제작된 데스크탑 환경을 사용하는 리눅스 배포판

> :bulb: GNU/Linux란?

- 리눅스 커널: 운영체제의 핵심 부분으로, 하드웨어와 소프트웨어를 연결하는 역할

- GNU 프로젝트: 리처드 스톨먼이 주도한 자유 소프트웨어 프로젝트로, 리눅스 운영체제에서 필수적인 도구와 프로그램을 제공


### 🤔우분투 왜 써?
- ✅개인용 PC 환경에 최적화
- ✅간결하고 쉬운 난이도
- ✅많은 사용자를 기반으로 한 많은 레퍼런스
- ✅약 6개월 단위로 업데이트
- ✅GUI 인터페이스 존재

### 📆우분투 버전 표시
일년에 두 차례 새로운 버전을 공개하는데 나온 년도와 달로 번호를 지정한다.

> EX) 24.04 - 24년도 4월 공개

`LTS 버전`도 존재하는데 `Long Term Support`의 약어로 가장 안정적인 버전이다!


## 💻리눅스 기초 명령어
Shell(셸)을 통해서 Kernel(커널)에 명령을 요청합니다.

🛠 Shell의 종류에는 Bash, Sh, csh, Ksh등등이 있는데 리눅스의 기본 Shell은 Bash 입니다.

✅ whoami

```Bash
elicer ~$ whoami

> elicer
```
➡️ 로그인한 사용자 ID를 알려주는 명령어입니다.


✅ passwd

```Bash
elicer ~$ passwd

Enter new UNIX password:
Retype new UNIX password:
passwd: password updated successfully
```
➡️ 현재 로그인한 사용자 비밀번호 변경

✅ pwd

```Bash
elicer ~$ pwd

/elicer/currentDirectory
```
➡️ 현재 디렉토리 위치를 출력


✅ ls 

```Bash
elicer ~$ ls

elice_dir main.py conf.d try.sh
```
➡️ 현재 디렉토리의 목록을 출력

✅ ls -a

```Bash
elicer ~$ ls -a

.   .cash   .profile    바탕화면
..  .config  공개        비디오
```
➡️ 숨겨진 파일이나 디렉토리를 포함하여 출력


✅ ls -al

```Bash
elicer ~$ ls -al

drwxr-xr-x 1 elicer elicer   21 Sep 10 09:22 .
drwxr-xr-x 1 elicer elicer   26 Sep 10 09:42 ..
-rw-r--r-- 1 elicer eclier 4096 Mar 19 17:15 .cash
```
➡️ 숨겨진 파일과 디렉토릴르 포함해 현재 디렉토리의 목록을 상세히 출력

✅ cd

```Bash
elicer~$ cd my_project
elicer~/my_project$ 
```
➡️ 해당 디렉토리로 이동


✅ --help

```Bash
elicer~$ ls --help

Usage: ls [OPTUIN]...[FILE]...
List information about the FILEs (the current directory by default).
.
.
.
```
➡️ 사용하고자 하는 명령어 뒤에 붙여서 사용하고 명령어에 대한 사용 방법이 출력


## GUI vs CLI
### 🎨GUI
`Graphical User Interface`의 약자로 사용자가 편리하게 사용할 수 있도록 기능을 아이콘, 이미지 등의 `그래픽`으로 나타낸 `인터페이스`

➡️ Windows와 Mac 운영체제 모두 GUI 사용


### 💻CLI 
`Command Line Interface`의 약자로 `문자를 통해서` 사용자와 컴퓨터가 상호작용하여 동작하는 `인터페이스`

➡️ Windows의 CMD, Mac의 Terminal은 CLI를 사용


## 📦패키지 관리자 - apt
`Advanced Packaging Tool`의 약자로 데비안 리눅스(.dev) 또는 파생된 배포판(우분투)에서 소프트웨어를 `설치, 제거, 업데이트` 할 때 사용

### apt-get
기존에 사용하던 키워드로 최신 우분투 버전에서는 `apt`라는 키워드로 사용


### 명령어
- apt install
- apt remove
- apt update
- apt search
- apt show


### 만약 권한이 없다면?
`sudo` 라는 키워드를 앞에 붙여 권한 획득 가능하다


## root
리눅스에서 모든 권한을 가지고 있는 최고 관리자를 뜻함. 운영체제에 모든 것을 제어할 권리를 가짐.
"`sudo` 사용할 명령어" 의 방식으로 권한 획득 가능

> EX) sudo apt install package


# 2. 리눅스 파일 시스템
## 리눅스 파일 시스템
저장 장치 내에서 데이터를 읽고 쓰기 위해 미리 정한 약속


- `디렉토리(Directories)` + `파일(File)` 형태로 구성되어 있음
- `루트` 파일 아래에 `계층적`으로 모든 파일과 디렉토리가 만들어짐


### 파일
주기억장치나 디스크처럼 물리적인 `하드웨어`이며 저장 공간에 저장되는 `데이터의 집합`


### 디렉토리
`파일`과 `하위 디렉토리`들을 그룹으로 묶은 개념




## 디렉토리의 구조
```
root
├── bin
├── bin
├── user
├── home
│   ├── elice
│   │   ├── 바탕화면
│   │   ├── 문서
│   │   ├── 다운로드
```
리눅스 파일 시스템의 디렉터리 구조는 트리(tree) 구조 입니다.

> `tree` 명령문을 통해 확인 가능합니다



## 소유권과 권한
`ls -al` 명령어를 통해 파일 속성 확인

### 파일 속성
```
- rw-r--r-- 1 elice elice 8980 9월 16 09:35 elice.txt
```
|🧱 항목|📝 설명|
|-------|----------|
|-|📁 파일 유형: -는 일반 파일을 의미함|
|rw-r--r--|	🔐 파일 권한: 사용자/그룹/기타의 접근 권한 표시|
|1|	🔗 하드 링크 수: 해당 파일을 참조하는 링크 수|
|elice|	👤 파일 소유자: 파일을 만든 사용자 이름|
|elice|	👥 파일 소유 그룹: 소유자가 속한 그룹 이름|
|8980|	📦 파일 크기: 바이트(byte) 단위 크기|
|9월 16 09:35|	🕒 최종 수정 시간: 파일이 마지막으로 수정된 날짜와 시간|
|elice.txt|	🗂️ 파일 이름: 실제 파일의 이름|


### 파일의 권한 
- `r` = 4
- `w` = 2
- `x` = 1
- `-` = 0
```
rw-r--r-- 을 숫자로 표현하면

rw- = 4 + 2 + 0 = 6
r-- = 4 + 0 + 0 = 4
r-- = 4 + 0 + 0 = 4

3자리씩 끊어서 표현한다.
644
```

### 파일의 권한 변경
```
chmod [파일권한] [변경할 파일 위치 또는 이름]
```

파일 권한은 읽기(4), 쓰기(2), 실행(1), (0) 으로 숫자로 표현

`777 권한`은 모든 사용자가 모든 권한을 얻는다는 의미


### 파일 소유권 변경
```
chown [소유할 유저]:[소유할 그룹] [소유권 변경하고 싶은 디렉토리 or 파일 명]
```

`root` 권한이 있어야 실행 가능


## 파일 명령어

### mkdir
```
mkdir [생성할 디렉토리 이름]
``` 


현재 디렉토리 위치에 새로운 디렉토리 생성

```
mkdir [디렉토리 경로/디렉토리명]
```
디렉토리 명 지정 가능


### touch
```
touch [생성할 파일 이름]
```
`빈 파일`을 생성합니다.

똑같이 `/파일명` 을 붙여주면 사용 가능


### rmdir
```
rmdir [삭제할 디렉토리 이름]
```
`비어있는` 디렉토리를 삭제

디렉토리에 `파일`이 있을 경우 `삭제 불가`


### rm
```
rm [option] [삭제할 파일 및 디렉토리 명]
```
- option 종류
    - `-r` : 디렉토리와 그 하부 파일까지 삭제
    - `-f` : 강제 삭제
    - `-i` : 삭제할지 확인 후 삭제
    - `-rf` : 강제로 하부 파일까지 삭제


### cp
```
cp [option] [대상 위치 및 이름] [복사하고 싶은 위치]
```

- option 종류
    - `-r` : 하위 디렉토리와 파일 전체 복사
    - `-p` : 소유주, 그룹, 권한, 시간 정보를 그대로 복사사

### mv
```
mv [대상 위치/이름] [이동하고 싶은 위치/이름]
```
이동하고 싶은 위치에 같은 이름의 파일/디렉토리 명이 존재하지 않을 경우 이동


### cat
```
cat [option] [파일 이름]
```

- option
    - `-n` : 왼쪽에 줄 번호와 함께 내용을 출력한다.
    - `>` : 파일의 내용을 덮어 쓴다.
    - `>>` : 파일의 내용이 있다면 뒤에 내용을 추가한다.


### find
```
find [파일 경로] [-name] [파일 이름] [-type d/f]
```
지정된 [파일 경로]에서 이름이 [파일 이름]인 파일 및 디렉토리를 검색하는 명령어


> :bulb: [사용하려는 명령어] --help

-> 사용하려는 명령어의 도움말을 화면에 출력력


## nano editor
나노 텍스트 에디터는 UNIX 호환 시스템에서 사용 가능한 텍스트 에디터입니다.

### 나노 에디터 실행
```
nano [편집하려는 파일 이름]
```

### ⌨️ 나노 에디터 주요 단축키

| 단축키           | 기능 설명                             |
|------------------|----------------------------------------|
| `Ctrl + O (^O)`  | 💾 저장 (Write Out)                   |
| `Ctrl + X (^X)`  | ❌ 종료 (Exit)                         |
| `Ctrl + G (^G)`  | 📖 도움말 보기                         |
| `Ctrl + W (^W)`  | 🔍 검색 (Find text)                   |
| `Ctrl + K (^K)`  | ✂️ 현재 줄 잘라내기 (Cut line)         |
| `Ctrl + U`       | 📃 복사하기                        |
| `Ctrl + U (^U)`  | 📋 붙여넣기 (Uncut/paste line)        |
| `Ctrl + C (^C)`  | 📌 커서 위치 및 줄 정보 표시          |
| `Ctrl + _ (^_)`  | 📍 특정 줄로 이동 (Go to line)         |
| `Alt + A`        | 📐 블록 선택 시작/해제 (Mark text)     |
| `Ctrl + J`       | 📎 정렬 (Justify)                      |




# 3. 알고 쓰는 리눅스 명령어
## 정규표현식
정규 표현식 (Reqular expression)은 `특정한 규칙`을 가진 `문자열의 집합`을 표현하는데 사용하는 형식


### 정규표현식 문법
특정 문자들은 특정한 논리적 관계를 나타내는 기호이며 이를 제외한 나머지는 일반적인 문자를 뜻함


### 📘 정규식 메타 문자

| 메타 문자 | 의미 설명                                |
|-----------|-------------------------------------------|
| `^`       | 문자열의 시작을 의미                      |
| `$`       | 문자열의 끝을 의미                        |
| `.`       | 줄바꿈 문자를 제외한 모든 문자와 매칭     |
| `\s`      | 공백 문자 (스페이스, 탭, 줄바꿈 등)       |
| `\S`      | 공백 문자를 제외한 모든 문자               |
| `\\`      | 역슬래시 자체 (`\`를 문자로 인식)         |
| `\d`      | 숫자 (0~9) 하나와 매칭                    |
| `\D`      | 숫자가 아닌 문자와 매칭                   |
| `\w`      | 문자, 숫자, 언더스코어 (`[a-zA-Z0-9_]`)  |
| `\W`      | 문자, 숫자, 언더스코어가 아닌 문자        |
| `\n`      | 줄바꿈 (newline) 문자                     |
| `\t`      | 탭 문자                                   |


### 선택 패턴
`|` 문자를 이용하면 `A|B` 의 패턴으로 매칭 가능하다.
예를 들어 `alice|elice` 라는 정규 표현식은 "alice"와 "elice" 라는 문자열을 모두 포함한다.

즉, alice 또는 elice 둘 중 하나라는 뜻뜻


### 선택 패턴
- `[]` 대괄호 속에 넣은 문자 중에서 하나에 매칭
- `[0-9]` 0부터 9까지의 숫자 하나에 매칭
- `[A-Z]` A부터 Z까지의 알파벳 대문자 하나에 매칭

`[]` 내에서 `^` 기호는 not의 의미를 가지게 된다.


### 수량 한정자 

| 수량 한정자 | 의미 설명                                             |
|-------------|--------------------------------------------------------|
| `?`         | 앞의 문자가 **0개 또는 1개** 있을 때 매칭             |
| `*`         | 앞의 문자가 **0개 이상** 있을 때 매칭 (없어도 됨)     |
| `+`         | 앞의 문자가 **1개 이상** 있을 때 매칭 (하나 이상 필수) |
| `{n}`       | 앞의 문자가 **정확히 n개** 있을 때 매칭               |
| `{n, m}`    | 앞의 문자가 **n개 이상 m개 이하** 있을 때 매칭        |
| `{n,}`      | 앞의 문자가 **n개 이상** 있을 때 매칭                  |


### 그룹 패턴

괄호 `()`는 정규표현식에서 **"묶기"** 역할을 해요!  
**한 덩어리로 인식해서** 나중에 다시 **참조하거나 반복**할 수 있죠.



### 📌핵심 개념
- `( )`로 감싸면 **하나의 그룹**으로 만들어짐
- 그룹은 정규식 내에서 **번호(1번, 2번...)로 참조** 가능
- 그룹에 들어간 내용이 **나중에 또 반복되는지 확인**할 때 유용



#### 🔁 예시
```regex
(to)ma\1
```


### 정규 표현식 사용 예
전화번호는 `일정한 패턴` 을 가진 문자열.
아래의 조건을 만족하는 전화번호를 찾는 정규표현식은?

1. 전화번호는 010으로 시작한다.
2. 전화번호의 가운데 자리는 네 자리이다.
3. 전화번호의 각 자리에 구분 문자가 있을 수도 있고, 없을 수도 있다.


> ^010(\D?\d{4}){2}


`^` : 시작 문자는 010

`\D?` : 숫자가 아닌 문자가 0개 이상

`\d{4}` : 숫자가 4개

`(\D?\d{4}){2}` : 앞의 그룹이 2개 존재


## grep
grep 명령은 파일 내에서 지정한 패턴이나 문자열을 찾은 후에 
그 패턴을 포함하고 있는 모든 행을 출력

> grep [option] [pattern] [파일명]

- option
    - `-i` : 대소문자를 구분하지 않고 검색한다.
    - `-v` : 패턴과 일치하지 않는 행을 출력한다.
    - `-c` : 패턴과 일치하는 행의 개수를 출력한다.
    - `-w` : 패턴과 단어 단위로 매칭되어야 출력한다.


### 예시
> grep elice hello.txt

hello.txt 파일에서 'elice'라는 문자열이 들어 있는 행을 모두 출력

<br>


> grep -c elice hello.txt

hello.txt 파일에서 'elice' 라는 문자열이 들어있는 행의 수 출력


### grep과 정규 표현식
> grep [0-9] hello.txt

hello.txt 파일에서 숫자가 존재하는 행을 모두 출력

<br>


> grep "Elice\.The\.Rabbit" *

현재 디렉토리의 모든 파일에서 Elice.The.Rabbit 을 찾아 출력



## File Redirection
File Redirection 은 표준 스트림의 흐름을 바꾸어 일반적인 표준 입력 및 출력
그리고 오류를 사용하지 않고 다른 경로인 파일로 재지정하는 것을 뜻합니다.


### Standard Stream
일반적으로 표준 입력, 표준 출력, 표준 오류 출력으로 분류
스트림은 문자열로 콘솔에 출력되로록 설정되어 있음


- `stdin` : 키보드 입력
- `stdout` : 화면 출력
- `stderr` : 오류 내용 출력


표준 오류는 연산자를 사용하지 않으며 파일디스크립터 번호를 `>` 앞에 작성해서 사용

- `0` : 표준 입력
- `1` : 표준 출력
- `2` : 표준 에러


## Piping commands
### Linux Pipe
Pipe는 둘 이상의 명령어를 묶어 출력의 결과를 다른 명령으로 전환할 수 있는 기능

명령어의 표준 출력을 또 다른 명령어의 표준 입력으로 연결

`|` 기호를 사용하여 명령어와 명령어를 연결

<br>

> head a.txt | grep [0-9]

1. head 명령을 실행하여 a.txt의 첫 10줄을 출력
2. 출력된 결과를 | (pipe)를 통해 grep 명령으로 전달
3. 숫자가 포함된 행을 가진 행의 결과가 모두 출력



## 마운트
### 마운트 (mount)
mount란 물리적인 저장 장치 (보조기억장치)를 디렉토리 (또는 폴더)에 연결시켜 주는 것을 말함


윈도우에서는 하드, USB등의 보조기억장치를 연결하면 자동으로 폴더에 연결됨


이것을 PnP(Plug and Play)라고 합니다.
-> 리눅스는 직접 연결해야 함.


> mount [option] [device] [directiory]

- option
    - `-a` : /etc/fstab에 명시된 파일 시스템을 마운트 할 때 사용
    - `-t` : 파일 시스템의 유형을 지정, 생략할 시 /etc/fstab 파일을 참조
    - `-o` : 추가적인 설정을 적용할 때 사용, 다수의 조건을 적용할 때는 , 로 구분


> mount [device] [directiory]

-> mount 를 취소하는 명령어


> df

-> 현재 mount 된 디스크 정보 출력력



# 4. 프로세스와 네트워크
## 프로세스
리눅스 시스템에서 메모리에 적재되어 실행되고 있는 모든 프로그램이 프로세스이다.


### 특징
1. 모든 프로그램은 하나 이상의 프로세스를 갖고 실행된다.
2. 병행적으로 실행이 가능하다.
3. 부모 자식 프로세스가 있게 된다.
4. 커널에 의해 관리된다.
5. 모든 프로세스에는 소유자가 있다.
6. 프로세스마다 식별을 위한 ID가 부여된다.


### 프로세스의 번호
- PID 1번은 시스템 초기화를 담당하는 `init` 또는 `systemd` 프로세스이다.
- PID 2번은 보통 `kthreadd`이며, 커널 스레드 생성을 담당한다.

> :bulb: init 프로세스 -> 나머지 모든 시스템 프로세스의 부모 프로세스


> :bulb: thread 프로세스 -> 모든 스레드의 부모 프로세스


### 프로세스의 메모리 구성
1. 코드 영역
- 프로그램 `코드`를 뜻함

2. 데이터 영역
- `전역 변수`와 `정적 변수`

3. BSS 영역
- `초기화`되지 않은 `변수`

4. 힙 영역
- `동적인 메모리` 할당영역

5. 스택 영역
- 함수 매개변수, 복귀 주소, 지역 변수와 같은 `임시 자료`

6. 커널
- `kernel`


## 프로세스 명령어
### ps
프로세스 목록 보기 명령어

> ps [option]

option
- `-e` : 현재 실행 중인 모든 프로세스 정보 출력 
- `-f` : 모든 정보 확인
- `-a` : 실행중인 전체 사용자의 모든 프로세스 출력
- `-u` : 프로세스를 실행한 사용자와 프로세스 시작 시간 등을 출력
- `-x` : 터미널 제어 없이 프로세스 현황 보기

> :bulb: 옵션을 합쳐서 사용 가능하기도 함



### kill
프로세스 종료 명령어

> kill [option] [PID:프로세스 아이디]

option
- `-l` : 사용 가능한 시그널 목록 출력

자주 사용하는 시그널 
- `-1` : 재실행(SIGHUP)
- `-9` : 강제종료(SIGKILL)
- `-15` : 정상 종료(SIGTERM)


## ✅ job
job 명령어는 현재 터미널에서 백그라운드로 실행 중인 작업 목록을 확인할 때 사용해요.


### 💡 핵심 개념 정리
1. job은 **현재 쉘(터미널 세션)**에서 실행한 백그라운드 작업을 추적한다.

2. 이 명령어는 터미널에서 실행된 작업만 보여준다.
→ 다른 터미널에서 실행한 작업은 보이지 않아.

3. 터미널을 종료하면, 해당 터미널에서 실행한 백그라운드 작업(job)도 함께 종료된다.
→ 즉, job은 터미널에 종속되어 있음.

4. 각 터미널마다 자기만의 job 리스트를 가진다.


> 프로세스와 마찬가지로 kill 명령어를 통해 종료 가능.

> kill %작업번호



## at과 cron
지정된 시간에 1회 실행되는 작업 예약 명령어

시간이 되면 수행되고 작업 리스트에서 사라진다

### at
> at [옵션] [시간] [날짜] [+증가시간]

option
- `-m` : 출력 결과 없어도 작업이 완료될 때 사용자에게 메일을 보냄
- `-f` : 스크립트 파일 등을 실행할 때 사용
- `-l` : 예약된 작업 목록 출력, atq 명령어 또한 같은 동작을 수행
- `-v` : 작업이 수행될 시간 출력
- `-d` : 예약된 작업을 삭제, atrm 명령어 또한 같은 동작을 수행

### crontab
지정된 시간에 1회 실행되는 at과는 달리 지정된 시간에 따라 `주기적`으로 실행

>crontab [옵션]

option
- `-l` : 현재 계정의 설정된 crontab 정보를 보여준다. 
- `-e` : 현재 계정의 crontab 정보를 수정한다.
- `-r` : 현재 계정의 crontab 정보를 모두 삭제한다.
- `-u` : 특정 사용자의 crontab 정보를 다루게 해준다.(root 권한 필수)



## SSH
`Secure Shell`의 줄임말로 네트워크를 통해 다른 컴퓨터에 `접근`하거나 그 컴퓨터에서 `명령 실행` 등을 할 수 있도록 해주는 `프로토콜`


### Telnet과 SSH
Telnet 또한 네트워크를 통해 다른 컴퓨터에 `접근`하거나 그 컴퓨터에서 `명령 실행` 등을 할 수 있도록 해주는 프로토콜이나, `보안적`으로 매우 치명적인 `결함`이 존재한다.

> Telnet의 패킷 데이터는 암호화 되어 있지 않다.

하지만 SSH의 데이터는 `암호화` 되어 있다.


### openssh
우분투에서는 openssh 라는 패키지를 통해 SSH를 구동할 수 있다.

다른 컴퓨터에서 우분투에 접속하려면 openssh-server 패키지를 설치해야 한다.


### ssh 서버 실행하기
> sudo service ssh start


### ssh 포트 확인하기
> sudo netstat -antp


### ssh 접속하기
> ssh [서버아이디]@[아이피 혹은 서버이름 혹은 도메인]

CMD 또는 터미널 창에서 다음의 명령어로 접속 가능
