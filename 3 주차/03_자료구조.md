# ✅ 3 주차 내용 정리

### 👉 목차
1. [자료 구조란?](#1-자료-구조란)
2. [리스트의 구조](#2-리스트의-구조)
3. [딕셔너리의 구조](#3-딕셔너리의-구조)


# ✅ 1. 자료 구조란?
## 📌 자료구조 개요
컴퓨터 과학에서 효율적인 접근 및 수정을 가능하게 하는 자료의 조직, 관리, 저장을 의미한다. 더 정확히 말해, 자료 구조는 데이터 값의 모임, 또 데이터 간의 관계, 그리고 데이터에 적용할 수 있는 함수나 명령을 의미한다.

### 👉 1D Data vs 2D Data
|1D Data|2D Data|
|--|--|
|1차원 데이터|2차원 데이터|
|리스트, 튜플, 집합 등|주로 많은 열과 행을 가진 표|

### 왜 배울까?
자료의 형태에 따라 저장하는 방법이 다르기 때문에, 자료구조를 이해하고 활용할 수 있어야 한다.

> 여우는 접시를, 두루미는 호리병을 써야 행복하게 음식을 먹을 수 있다.


- 마찬가지로 프로그램에서 특정 알고리즘을 구현하기 위해선 적절한 자료구조를 선택해야 좋은 성능을 낼 수 있다.



## 📌 추상적 자료형
자료와 그 자료에 대한 연산들의 수학적인 정의를 의미하고 그 정의를 구현하는 방법은 명시되어 있지 않다.


> 그릇은 `음식`을 보관하고, 그릇에 담긴 음식을 `먹을 수 있다`.

-> 음식 : 자료, 먹는 것 : 연산

```
'그릇'이라는 추상적 자료형이 있고, 그릇에 음식을 어떻게 담을지, 어떻게 먹을지 명확히 구현된 것을 '자료구조'라고 할 수 있어요.
```

### 👉 정리하면
- 추상적 자료형 : 자료들과 그 자료에 대한 연산들을 개념적으로 정의만 한 것
- 자료구조 : 추상적 자료형을 구현하여 연산을 구체적으로 제공한 것

> `추상적 자료형`을 `구체적으로 구현`한 결과가 `자료구조`


## 📌 배열과 연결 리스트
### 👉 배열(Array)
- 지금까지 배운 리스트라는 추상적 자료형을 구현한 대표적인 예시가 바로 `배열`이다.


배열에 저장되는 값들은 순서를 나타내는 번호를 가진다. 이 번호를 `인덱스` 라고 불러요.

```
인덱스(index):    0       1       2       3       4
배열(array):   [10]    [20]    [30]    [40]    [50]
```

> array[2] = 30


### 👉 배열 - 조회
배열 내의 특정 순서의 값을 조회하고자 할 때 단번에 찾아낼 수 있어요.

### 👉 배열 - 삽입
자료를 추가할 땐 조금 번거로운데, 새로운 자료가 추가되면서 기존의 자료들의 순서를 변경해주어야 해요.

- 새로운 자료가 들어갈 공간을 마련해주어야 합니다. 
- 해당 인덱스에 들어가기 위해 공간을 비우고 기존 자료들은 한 칸씩 밀려납니다.
- 이 빈 공간에 추가될 값을 넣어줍니다.


### 👉 배열 - 삭제
위의 삽입의 과정을 반대로 진행하면 됩니다.

- 제거할 인덱스를 비웁니다.
- 자료가 줄었으니 빈 자리를 메꾸기 위해 자료들이 한 칸씩 앞으로 이동합니다.
- 마지막 자료는 비워줍니다.


### 👉 근데 리스트랑 무슨 차이야?
| 비교 항목     | 리스트 (`list`) 🧵                     | 배열 (`array`) 🧱                        |
|---------------|----------------------------------------|------------------------------------------|
| 저장 타입     | 다양한 자료형 섞어서 저장 가능          | 같은 자료형만 저장 가능                  |
| 조회 속도     | 빠름 (`my_list[2]`)                    | 빠름 (`my_array[2]`)                     |
| 삽입/삭제 성능| 느림 (중간에 넣거나 빼면 밀고 당겨야 함) | 느림 (동일하게 밀고 당기는 작업 필요)   |
| 메모리 효율   | 비효율적 (자료형마다 크기 다름)         | 효율적 (고정된 자료형이라 메모리 절약)  |
| 연산 기능     | 기본 연산만 지원                        | 수치 연산 등 고급 연산 지원 (`numpy`)   |
| 사용 예       | 일반적인 데이터 저장에 적합             | 대량의 수치 데이터 처리에 적합          |


>💡 한 줄 요약: 리스트로도 다 할 수 있지만,
배열은 메모리 절약과 빠른 수치 연산이 필요할 때 유리해요!



### 👉 연결 리스트(Linked List)
리스트를 구현한 자료구조 중 대표적인 다른 예시는 `연결 리스트`입니다.

- 연결 리스트는 여러 개의 '노드'를 저장하는 방식으로 구현해요.

```
[10] -> [20] -> [30] -> [40] -> [50] -> None
```

### 👉 연결 리스트 - 조회
노드끼리 연결되어있죠? 그래서 연결 리스트(Linked List)라고 불러요.

- 따라서 찾는 자료의 위치가 시작점으로부터 멀 수록 연산 횟수가 많아져요!


### 👉 연결 리스트 - 삽입
추가할 위치의 이전 노드의 포인터를 새로운 노드로, 새로운 노드의 포인터를 이전 노드가 가리키던 노드로 설정합니다.

```python
삽입 전: [10] -> [20] -> [30] -> [40] -> None

중간에 25 삽입 후:
[10] -> [20] -> [25] -> [30] -> [40] -> None
```

### 👉 연결 리스트 - 삭제
제거할 노드의 이전 노드의 포인터를 제거할 노드의 다음 노드를 가리키도록 설정합니다.

```python
삭제 전: [10] -> [20] -> [30] -> [40] -> None

삭제 후: [10] -> [20] -> [40] -> None
```

### 👉 연결리스트는 왜 쓸까?
인덱스를 이용하여 절대적인 순서를 표현하는 배열과는 달리,
연결 리스트는 노드의 상대적인 순서로 표현합니다.

- 따라서 삽입과 삭제에 유리해요!
- 단, 특정 위치의 자료를 탐색하는 데는 불리해요.



### 👉 배열과 연결 리스트 비교
| |배열|연결 리스트|
|-|----|---------|
|장점|특정 위치의 자료 탐색|자료의 삽입과 삭제|
|단점|자료의 삽입과 삭제|특정 위치의 자료 탐색|

> 💡 요점:
두 자료구조는 성격이 반대라서,
상황에 따라 적절히 선택해서 사용해야 성능이 좋아져요!



## 📌 자료구조의 구현 방법
객체지향 프로그래밍(OOP)에서는 `추상적 자료형은 인터페이스`, `자료구조는 클래스` 로 생각할 수 있어요.


### 👉 인터페이스
객체지향 구조에서 추상 메서드만으로 이루어진 설계용 클래스입니다.

구현 부분이 비어있는 메서드를 추상 메서드라고 하며, 상속받는 클래스에서 이를 구현하여 사용합니다.

```
즉, '리스트'라는 인터페이스에는 "삽입과 삭제를 지원해야 한다"는 명세만 주어지고 구현은 하지 않아요.

그 구현은 리스트를 상속받은 배열 클래스, 연결 리스트 클래스에서 구현합니다.
```

```python
class MyInterface(metaclass = ABCMeta):
    @abstractmethod # 추상 메서드임을 나타내는 데코레이
    def func():
        pass 
```

Python에서는 인터페이스 기능을 직접 제공하진 않아서 위와 같은 방법으로 표현합니다.


### 👉 자료구조 구현
```python
import queue

q = queue.Queue() # 큐 생성
```

`큐`라는 자료구조를 구현한 Queue 클래스도 있어요.

이와 같이 자료구조를 구현하기에는 클래스가 탁월합니다.


# ✅ 2. 스택과 큐
## 📌 스택, 큐의 개념
### 👉 대표적인 자료구조의 예시

- 선형구조 : 자료가 순서를 가지고 연속되어 있어요.
- 예시 : 배열, 연결 리스트, 스택, 큐

- 비선형구조 : 자료가 순서를 가지지 않고 비연속적으로 존재해요.
- 예시 : 트리, 그래프



## 📌 스택 (Stack)
한쪽 끝에서만 자료를 넣고 빼는 구조입니다.

> LIFO(Last In First Out) 구조 = 후입선출(나중에 들어온 자료가 먼저 나간다.)

> 한쪽만 뚫린 원통에 물건을 쌓아올리고, 가장 위에 있는 물건을 꺼내는 구조라고 생각하면 돼요.


### 👉 연산목록
- push : 자료를 넣는 연산
- pop : 자료를 빼는 연산
- top : 가장 위에 있는 자료를 조회하는 연산
- empty : 스택이 비어있는지 확인하는 연산


- list의 append, pop 연산을 지원해서 스택을 구현할 수 있어요.


## 📌 큐 (Queue)
입구와 출구가 각각 한 쪽 끝에 존재하는 자료구조

> FIFO(First In First Out) 구조 = 선입선출(먼저 들어온 자료가 먼저 나간다.)

> 양 쪽이 뚫린 원통에 물건을 넣고, 한 쪽에서 넣고 다른 쪽에서 빼는 구조라고 생각하면 돼요.

### 👉 연산 목록
- push : 자료를 넣는 연산
- pop : 자료를 빼는 연산
- front : 가장 앞에 있는 자료를 조회하는 연산
- back : 가장 뒤에 있는 자료를 조회하는 연산
- empty : 큐가 비어있는지 확인하는 연산


- 선형 구조이기 때문에 배열을 이용해서 구현이 가능하지만, **공간 낭비 등의 문제로 비효율적일 수 있어요.**


#### 문제점
- 큐가 가득 찬 상태
```
인덱스:   0  1  2  3  4
큐:     [A][B][C][D][E]
front = 0
rear  = 5
```


- pop을 통해 A, B, C를 제거한 상태
```
인덱스:   0  1  2  3  4
큐:     [ ][ ][ ][D][E]
front = 3
rear  = 5
```

- 그런데 push를 통해 F를 넣으려면 인덱스 5에 넣어야 하는데, 이미 가득 차있다고 판단해요.
- 따라서 배열을 이용한 큐는 비효율적이에요.

### 👉 원형 큐
배열로 큐를 구현할 때 문제점을 해결하기 위해 원형 큐를 사용해요.

- 배열의 끝에 도달하면 다시 처음으로 돌아가서 사용합니다.

```
인덱스:   0  1  2  3  4
큐:     [A][B][C][D][E]
front = 0
rear  = 0 ← 배열 끝까지 썼기 때문에 다시 처음으로 순환함


인덱스:   0  1  2  3  4
큐:     [ ][ ][ ][D][E]
front = 3
rear  = 0


큐:     [F][ ][ ][D][E]
         ↑
       rear = 1
```

- 원형 큐는 배열을 이용한 큐의 단점을 보완한 자료구조입니다.

### 👉 링크드 큐
연결 리스트를 이용한 큐입니다.

- 연결 리스트의 장점을 살려서 큐를 구현할 수 있어요.
- 삽입과 삭제가 용이하고, **필요한 만큼만 메모리를 사용하므로 효율적이에요.**


### 👉 큐 종류 비교 표

| 비교 항목           | 일반 큐 (Queue) 🧱              | 원형 큐 (Circular Queue) 🔁         | 링크드 큐 (Linked Queue) 🧵         |
|--------------------|-------------------------------|-----------------------------------|----------------------------------|
| **구조**           | 선형 배열 기반                  | 선형 배열 + 인덱스 순환 구조         | 노드와 포인터로 연결된 구조        |
| **공간 효율성**     | 낮음 (앞부분 공간 낭비 발생)       | 높음 (배열을 순환적으로 사용)         | 매우 높음 (필요한 만큼 동적 사용)    |
| **인덱스 문제**     | 있음 (rear가 끝에 도달함)         | 없음 (끝나면 0으로 되돌아감)         | 없음 (노드 연결만 바꾸면 됨)       |
| **구현 난이도**     | 쉬움                            | 보통 (모듈로 연산 필요)              | 다소 어려움 (클래스 및 포인터 필요) |
| **메모리 관리**     | 고정 크기 배열 사용                | 고정 크기 배열 사용                   | 동적 메모리 사용                    |
| **사용 예시**       | 간단한 큐 구조 구현                | 공간 재활용이 중요한 경우              | 대용량 처리, 무한 큐 등             |



- queue 모듈을 사용하면 큐를 쉽게 구현할 수 있어요.

```python
import queue
q = queue.Queue() # 큐 생성
```

> 스택과 큐를 실제로 사용하고자 할 때 스택은 파이썬의 리스트를, 큐는 queue 모듈을 사용하면 돼요!


## 📌 스택, 큐의 의미
### 👉 의미
스택과 큐는 가장 기본적인 형태의 자료구조 중 하나이며 스택과 큐의 의미를 알고 있어야 문제를 해결할 수 있어요.


### 👉 스택의 활용 예시
- 팩토리얼 연산을 예시로 들 수 있어요.

```python
def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1)
print(factorial(4))
```

이 함수는 자기 자신을 호출하는 `재귀 함수`입니다.

#### 과정
1. factorial(4)

2. → 4 * factorial(3)

3. → 4 * 3 * factorial(2)

4. → 4 * 3 * 2 * factorial(1)

5. → 4 * 3 * 2 * 1 * factorial(0)

6. → factorial(0)은 1 반환 (기저 조건)

- 그 다음 반환하는 과정을 거칩니다.

1. factorial(0) → 1 반환

2. factorial(1) → 1 × 1 = 1

3. factorial(2) → 2 × 1 = 2

4. factorial(3) → 3 × 2 = 6

5. factorial(4) → 4 × 6 = 24

```python
factorial(4) 호출됨
  factorial(3) 호출됨
    factorial(2) 호출됨
      factorial(1) 호출됨
        factorial(0) 호출됨
        반환: 1 (기저 조건)
      factorial(1) → 1 * factorial(0) = 1
    factorial(2) → 2 * factorial(1) = 2
  factorial(3) → 3 * factorial(2) = 6
factorial(4) → 4 * factorial(3) = 24
```

> 하나씩 호출이 쌓이고 반환하는 과정에서 스택 구조와 유사한 형태로 진행이 되고 있죠.

- 이와 같이 여러 작업들 사이에 의존 관계가 있을 때 스택을 사용합니다.

### 👉 큐의 활용 예시
- 🚌 현실 속 예시: 버스 정류장
사람들이 줄을 서서 버스를 기다려요.

- 먼저 도착한 사람이 먼저 탑승하죠.
→ 이것이 바로 선입선출(FIFO) 구조예요.

이와 같이 작업들 사이에 의존관계가 없다면 큐에 저장하여 관리할 수 있어요!


### 👉 정리
- 스택과 큐는 자료구조의 기본적인 형태로, 각각 LIFO와 FIFO 구조를 가지고 있어요.
- 스택은 후입선출 구조로, 큐는 선입선출 구조로 동작해요.

- 스택은 어떤 작업이 끝나고 나서 다음 작업을 수행할 때 사용하고,
큐는 작업들 사이에 의존관계가 없을 때 사용해요.


