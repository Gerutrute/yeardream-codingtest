# ✅ 3 주차 내용 정리

### 👉 목차
1. [트리](#1-트리)

# ✅ 1. 트리
## 📌 비선형구조와 트리
### 👉 비선형구조 대표적 예시
- 그래프
- 트리

### 👉 그래프
정점(vertex)과 간선(edge)으로 이루어진 자료구조입니다.

- 정점: 그래프의 점
- 간선: 정점과 정점을 연결하는 선

> 간단히 말해 점과 선으로 이루어진 관계도예요.

그래프의 간선은 방향이 있을 수도, 없을 수도 있어요.
- 방향이 있는 그래프 : 유향 그래프



### 👉 트리 * 개념이해
```
        A         ← 루트 노드
       / \
      B   C       ← A의 자식 노드
     / \   \
    D   E   F     ← 리프 노드
```
트리는 그래프의 일종으로, 다음과 같은 특징을 가지고 있어요.

- 모두 방향성을 갖는다.
- 사이클이 없다.
- 어떤 정점을 가리키는 정점의 개수는 최대 1개이다.
- 어떤 정점에서 다른 정점으로 이동할 수 있는 경로는 1개다.


> 루트 노드 : 트리의 최상단 노드(다른 어떠한 정점도 가리키지 않고 있는 정점)

> 깊이 : 루트 노드로부터의 거리


### 👉 트리의 예시
```
app
├── A
│   ├── D
│   └── E
└── C
    └── F
```
- 디렉토리 구조가 트리 구조로 되어 있어요.


### 👉 이진 트리
```
        A       
       / \
      B   C 
     / \   \
    D   E   F
```

이진 트리는 각 노드가 최대 2개의 자식 노드를 가질 수 있는 트리입니다.
- 자식 노드가 0개인 노드를 리프 노드라고 해요.


### 👉 포화 이진 트리
- 모든 노드가 자식 노드를 2개씩 가지고 있는 트리입니다.

```
        A
       / \
      B   C
     / \ / \
    D  E F  G  
```
> 리프 노드가 아닌 노드가 자식 노드를 1개만 가지면 포화 이진 트리가 아니에요.

- 포화 이진 트리는 노드의 개수가 2^h - 1개로 결정돼요.
- h는 트리의 높이입니다.

### 👉 완전 이진 트리
- 모든 노드가 자식 노드를 2개씩 가지고 있는 트리입니다.
- 단, 마지막 레벨은 비어있을 수 있어요.

```
        A
       / \
      B   C
     / \ / 
    D  E F  
```
- 포화 이진 트리와 비슷하지만, 마지막 레벨은 비어있을 수 있고, 가능한 가장 왼쪽에 위치해야 해요.

> 마지막 깊이의 정점이 오른쪽에서부터 일부 제거된 트리라고 볼 수 있어요!

### 👉 정 이진 트리
- 리프노드를 제외한 모든 노드가 2개의 자식 노드를 가지고 있는 트리입니다.

```
        A
       / \
      B   C
     / \ 
    D   E  
```
- 리프 노드를 제외한 모든 노드가 2개의 자식 노드를 가지고 있어요.


### 👉 🌲 이진 트리의 종류 비교 * 개념이해

| 트리 종류       | 정의                                                                 | 예시 구조 특징                         | 노드 조건                        |
|----------------|----------------------------------------------------------------------|----------------------------------------|----------------------------------|
| 이진 트리       | 모든 노드가 **최대 2개의 자식 노드**를 가짐                          | 자유롭게 비어 있을 수 있음             | 없음                             |
| 포화 이진 트리  | **모든 노드가 자식 노드를 2개**씩 가짐, **리프 노드 동일 깊이**       | 노드 개수 = 2^h - 1                     | 모든 레벨 가득 차야 함           |
| 완전 이진 트리  | 마지막 레벨을 제외하고 **모든 노드가 자식 2개**, 마지막은 **왼쪽 정렬** | 마지막 줄만 비어 있어도 허용           | 왼쪽부터 차례대 채워져야 함     |
| 정 이진 트리    | **리프 노드를 제외한 모든 노드가 자식 2개**를 가짐                     | 리프 노드는 자식 없어도 OK             | 중간 노드는 꼭 자식 2개 필요     |

---

### 👉 💡 요약

- ✅ **포화 이진 트리** → 꽉 찬 트리  
- ✅ **완전 이진 트리** → 거의 다 찼는데 마지막 줄만 비었음  
- ✅ **정 이진 트리** → 리프 빼고는 다 자식 2개  
- ✅ **이진 트리** → 그냥 최대 2개까지면 다 OK




## 📌 트리의 표현 방법
### 👉 이진 트리 표현하기
```python
class TreeNode:
    def __init__(self):
        self.left = None
        self.right = None
```
이진 트리의 각 노드들은 왼쪽 또는 오른쪽 자식 노드를 가리키는 포인터를 가지고 있어요.
- 왼쪽 자식 노드는 left, 오른쪽 자식 노드는 right로 표현해요.

### 👉 완전 이진 트리 표현하기
배열을 이용해 간단하게 번호를 붙이면 표현할 수 있어요.

```python
# 완전 이진 트리를 배열로 표현한 예시
tree = [None, 'A', 'B', 'C', 'D', 'E', 'F']

# 인덱스:
#        1
#      /   \
#     2     3
#    / \   /
#   4   5 6

# 트리 출력 함수 (부모 - 자식 관계)
def print_tree(tree):
    for i in range(1, len(tree)):
        left = 2 * i
        right = 2 * i + 1
        print(f"부모 노드: {tree[i]}")
        if left < len(tree):
            print(f"  └─ 왼쪽 자식: {tree[left]}")
        if right < len(tree):
            print(f"  └─ 오른쪽 자식: {tree[right]}")
        print()

print_tree(tree)


> # 출력
[1] 부모 노드: A
  └─ 왼쪽 자식 [2]: B
  └─ 오른쪽 자식 [3]: C

[2] 부모 노드: B
  └─ 왼쪽 자식 [4]: D
  └─ 오른쪽 자식 [5]: E

[3] 부모 노드: C
  └─ 왼쪽 자식 [6]: F
```



## 📌 🌲 트리 순회(Tree Traversal)

트리의 모든 노드를 특정한 순서에 따라 방문하는 과정을 "순회(traversal)"라고 합니다.  
트리에 저장된 데이터를 활용하려면 **순회 방식**을 이해해야 해요.

> 📌 트리는 비선형 구조이기 때문에, 노드를 순서대로 접근하기 위해서는 순회가 필요합니다.

---

## 📌 🔍 순회 방식 종류

- **DFS** (Depth-First Search, 깊이 우선 탐색)
- **BFS** (Breadth-First Search, 너비 우선 탐색)

---

## 🧭 DFS (깊이 우선 탐색)

DFS는 **트리의 깊이를 우선적으로 탐색**하는 방식입니다.  
한 경로를 끝까지 내려간 뒤, 다시 돌아와서 다른 경로를 탐색합니다.  
재귀 함수나 **스택(stack)** 자료구조를 이용하여 구현할 수 있어요.

> 🔽 아래로 계속 내려가다가 더 이상 내려갈 곳이 없을 때, 다시 위로 올라와 다른 경로로 갑니다.



### 🌿 DFS 종류 (3가지 순회 방식) *** 코드주어지면 구현할 수 있을 정도로 숙지

| 순회 방식   | 방문 순서                                |
|------------|------------------------------------------|
| 전위 순회  | 루트 → 왼쪽 서브 트리 → 오른쪽 서브 트리 |
| 중위 순회  | 왼쪽 서브 트리 → 루트 → 오른쪽 서브 트리 |
| 후위 순회  | 왼쪽 서브 트리 → 오른쪽 서브 트리 → 루트 |


### ✅ 전위 순회 (Pre-order Traversal)

> 방문 순서: **루트 → 왼쪽 자식 → 오른쪽 자식**

```
    A
   / \
  B   C
 / \   \
D   E   F
```
📌 순서: A → B → D → E → C → F  
✅ 결과: `A, B, D, E, C, F`


### ✅ 중위 순회 (In-order Traversal)

> 방문 순서: **왼쪽 자식 → 루트 → 오른쪽 자식**
```
    A
   / \
  B   C
 / \   \
D   E   F
```
📌 순서: D → B → E → A → C → F  
✅ 결과: `D, B, E, A, C, F`


### ✅ 후위 순회 (Post-order Traversal)

> 방문 순서: **왼쪽 자식 → 오른쪽 자식 → 루트**
```
    A
   / \
  B   C
 / \   \
D   E   F
```
📌 순서: D → E → B → F → C → A  
✅ 결과: `D, E, B, F, C, A`


## 🌊 BFS (너비 우선 탐색)

BFS는 트리나 그래프에서 **가까운 노드부터 탐색**하는 방식입니다.  
즉, 루트에서 시작하여 같은 깊이에 있는 노드들을 모두 방문한 뒤, 다음 레벨로 이동합니다.

> 👉 보통 `큐(queue)` 자료구조를 이용해 구현합니다.
```
    A
   / \
  B   C
 / \   \
D   E   F
```

📌 순서: A → B → C → D → E → F  
✅ 결과: `A, B, C, D, E, F`

## 📌 서브 트리(Subtree)

트리에서 어떤 노드를 루트로 하는 **작은 트리**를 서브 트리라고 합니다.

```
    A
   / \
  B   C
 / \ / \
D  E F  G
```

이 트리에서 B, D, E는 **왼쪽 서브 트리**, C, F, G는 **오른쪽 서브 트리**가 됩니다.

> 서브 트리를 완전히 탐색한 후 루트 또는 다른 서브 트리로 이동하는 흐름을 이해하면 DFS 순회 방식이 훨씬 명확해져요!


### BFS 구현하기
BFS는 큐를 사용하여 구현할 수 있어요.

> 현재 정점과 이웃한 정점일 수록 먼저 방문해야 하므로  FIFO(First In First Out) 방식으로 구현합니다.

```python
# BFS 구현 예시
class Tree:
    def __init__(self, i, l, r):
        self.index = i
        self.left = l
        self.right = r
    
    def addNode(self, i, l, r):
        if self.index == None or self.index == i:
            self.index = i
            self.left = Tree(l, None, None) if l != None else None
            self.right = Tree(r, None, None) if r != None else None
        else:
            if self.left != None:
                if self.left.addNode(i, l, r) == True:
                    return True
            if self.right != None:
                if self.right.addNode(i, l, r) == True:
                    return True
            return False
```


## 트리의 활용
### 시간 복잡도
`배열`의 연산을 다시 복습해보자.

1. [1, 2, 5, 6] 의 배열이 존재한다.
2. 4를 추가하고 싶다.
3. 4를 추가하기 위해서는 5, 6을 뒤로 밀어야 한다.
4. 1을 삭제하고 싶다.
5. 1을 삭제하고 빈 공간이 생긴다.
6. 2, 5, 6을 앞으로 당겨야 한다.

> 정렬된 상태를 유지하는 배열의 추가와 삭제 연산은 O(n)의 시간 복잡도를 가집니다.


#### 이진 탐색
정렬된 자료구조에서 사용할 수 있는 탐색 알고리즘 이진 탐색을 이용하면 정렬된 배열 내에서의 자료 탐색을 O(log n)으로 줄일 수 있어요.

- 이진 탐색은 배열을 반으로 나누어 탐색하는 방식입니다.

```
1. 배열의 중간값을 찾는다.
2. 중간값과 찾고자 하는 값이 같으면 탐색 종료.
3. 중간값보다 작으면 왼쪽 배열을 탐색한다.
4. 중간값보다 크면 오른쪽 배열을 탐색한다.
5. 1~4를 반복한다.


# 만약 1부터 100까지 정렬된 배열에서 22을 찾는다면?
1. 중간값 50과 비교한다. (횟수 1)
2. 50보다 작으므로 왼쪽 배열을 탐색한다.
3. 중간값 25와 비교한다. (횟수 2)
4. 25보다 작으므로 왼쪽 배열을 탐색한다.
5. 중간값 12와 비교한다. (횟수 3)
6. 12보다 크므로 오른쪽 배열을 탐색한다.
7. 중간값 18과 비교한다. (횟수 4)
8. 18보다 크므로 오른쪽 배열을 탐색한다.
9. 중간값 21과 비교한다. (횟수 5)
10. 21보다 크므로 오른쪽 배열을 탐색한다.
11. 중간값 23과 비교한다. (횟수 6)
12. 23보다 작으므로 왼쪽 배열을 탐색한다.
13. 중간값 22와 비교한다. (횟수 7)
14. 22와 같으므로 탐색 종료.

최악의 경우 7번의 비교로 22를 찾을 수 있다.
```

#### 정렬된 배열의 시간 복잡도
- 추가: O(n)
- 삭제: O(n)
- 탐색: O(log n)

### 이진 탐색 트리 **
이진 탐색 트리는 이진 트리의 일종으로, 다음과 같은 특징을 가지고 있어요.

- 항상 정렬된 상태를 유지한다.
- 왼쪽 서브 트리의 모든 값은 루트보다 작고, 오른쪽 서브 트리의 모든 값은 루트보다 크다.

- 모든 서브 트리도 이진 탐색 트리여야 한다.

#### 탐색 과정
```
        5
       / \
      3   7
     / \   \
    2   4   8
```


✅ `1단계` : 
루트: 5
→ 8 > 5 → 오른쪽 자식 7로 이동

✅ `2단계` : 
현재 노드: 7
→ 8 > 7 → 오른쪽 자식 8로 이동

✅ `3단계` : 
현재 노드: 8
→ 찾고자 하는 값과 같음 → 탐색 성공!

```
        5
          \
           7
             \
              8 ← 찾음!

총 3번의 비교
→ 이진 탐색 트리에서의 탐색은 트리의 높이만큼만 진행됩니다.
→ 노드 수가 많아져도, 높이는 log₂(n) 정도로 증가
→ 시간 복잡도: O(log n)
```

#### 추가 과정
```
        5
       / \
      3   7
     / \   \
    2   4   8
```

✅ `1단계` : 
현재 노드: 5
→ 6 > 5 → 오른쪽 자식 7로 이동

✅ `2단계` : 
현재 노드: 7
→ 6 < 7 → 왼쪽 자식이 없음 →
👉 여기에 새로운 노드 6을 추가

```
        5
       / \
      3   7
     / \  / \
    2  4 6   8
```
- 값 6은 루트(5)부터 시작해서 오른쪽(7), 왼쪽(null)에 도달해 3단계 만에 삽입 완료

> 이처럼 **이진 탐색 트리의 삽입도 탐색과 동일하게 O(log n)**의 시간 복잡도를 가집니다.


#### 삭제 과정
```
        5
       / \
      3   7
     / \  / \
    2  4 6   8
```
🔹 `예1`. 단말 노드 삭제 `(노드 2)`

노드 2는 자식이 없는 단말 노드입니다.

과정

루트(5) → 왼쪽(3) → 왼쪽(2)

→ 2는 단말 노드 → 그냥 삭제하면 됨
- 예1 결과
```
        5
       / \
      3   7
       \  / \
        4 6  8
```


🔹 `예2`. 자식이 하나인 노드 삭제 `(노드 7)`

노드 7은 오른쪽 자식(8)만 있음

과정

루트(5) → 오른쪽(7)

→ 자식이 하나 → 자식 노드(8)를 부모 노드(5)의 오른쪽에 연결
- 예2 결과
```
        5
       / \
      3   8
     / \
    2   4
         \
          6
```

🔹 `예3`. 자식이 두 개인 노드 삭제 `(노드 3)`

노드 3은 왼쪽(2), 오른쪽(4) 자식이 있음

이때는 "후계자(successor)" 혹은 "선행자(predecessor)"로 대체합니다.

보통은 오른쪽 서브트리에서 가장 작은 값을 찾는 게 일반적이에요.

→ 오른쪽 자식인 4를 올려서 3의 자리에 배치
→ 이후 4의 원래 자리는 제거

- 예3 결과
```
        5
       / \
      4   7
     /   / \
    2   6   8
```

