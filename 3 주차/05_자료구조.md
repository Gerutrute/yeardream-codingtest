# 3 주차 내용 정리

### 목차
1. [우선순위 큐와 힙](#1-우선순위-큐와-힙)


# 1. 우선순위 큐와 힙

## 우선순위 큐의 구현 방법과 힙
### 우선순위 큐란?
우선순위가 높은 원소가 먼저 출력되는 추상적 자료형


#### 우선순위 큐의 구현 방법
큐로 간단하게 구현해보자

```python
from collections import deque

class PriorityQueue: # 우선순위 큐 클래스
    def __init__(self):
        self.queue = deque()

    def push(self, item): # 원소 추가
        self.queue.append(item)

    def pop(self): # 가장 큰 원소 제거
        if not self.queue:
            return None
        max_item = max(self.queue) # 가장 큰 원소 찾기
        self.queue.remove(max_item) # 가장 큰 원소 제거
        return max_item

    def is_empty(self): # 큐가 비어있는지 확인
        return len(self.queue) == 0
```

이처럼 단순한 방식으로 구현한 경우, 아래와 같은 시간 복잡도를 가집니다.
- 입력 : O(1)
- 출력 : O(n) (가장 큰 원소를 찾기 위해 큐를 모두 탐색해야 함)

> 너무 비효율적!!


### 힙
힙은 우선순위 큐를 구현하기 위한 자료구조로, 완전 이진 트리의 일종입니다.

- 최대 힙(Max Heap) : 부모 노드는 항상 자식 노드보다 큰 값을 갖고 있다.
- 최소 힙(Min Heap) : 부모 노드는 항상 자식 노드보다 작은 값을 갖고 있다.

```python
import heapq
```
파이썬의 heapq 모듈로 사용할 수 있습니다.


### ✅ 힙: 자료 입력하기 (최소 힙 기준)
완전 이진 트리의 특성을 유지해야 합니다.

따라서 입력된 자료는 항상 마지막 레벨의 가장 오른쪽 자리에 채워집니다.

입력 순서: `10 → 20 → 5 → 7 → 15`



#### 🌱 1단계: `10` 입력  
- 첫 노드이므로 루트에 삽입  

```
[10]
```
#### 🌱 2단계: `20` 입력  
- 왼쪽 자식 자리에 삽입  
- 부모(10)보다 크므로 자리 그대로  
```
    10
   /
 20
```

#### 🌱 3단계: 5 입력
오른쪽 자식 자리에 삽입

부모(10)보다 작으므로 swap

```
  입력 전:         입력 후 (swap):
    10                5
   / \               / \
 20   5   →         20  10
```

#### 🌱 4단계: 7 입력
다음 레벨의 왼쪽 자리에 삽입

부모(20)보다 작으므로 swap

```
  입력 전:           swap:              결과:
     5                 5                  5
    / \               / \                / \
  20  10   →        7   10     →       7   10
  /                /                  /
 7               20                 20
```

#### 🌱 5단계: 15 입력
오른쪽 자식 자리에 삽입

부모(10)보다 크므로 그대로 유지

```
     5
    / \
   7   10
  / \    \
20  15   (끝)
```

✅ **요약 정리**

힙은 항상 완전 이진 트리를 유지합니다.

삽입 시 항상 마지막 레벨의 가장 왼쪽 비어있는 자리부터 채웁니다.

삽입한 값이 부모보다 작으면 **부모와 자리 바꿈(swap)** 을 반복합니다.

이 과정을 통해 **힙의 성질(O(log n))** 을 유지합니다.


- 최악의 경우는 새로운 최솟값이 입력되고, 루트 노드까지 거슬러 올라갑니다.

- 이때 트리의 높이와 비례하므로 O(log n)입니다.

### ✅ 힙: 자료 출력하기 (최소 힙 기준)
힙에서 출력되는 자료는 무조건 루트 노드입니다.

현재 힙 상태:
```
     5
    / \
   7   10
  / \   
20  15
```

#### 🌾 1단계: 루트 노드 5 제거
마지막 노드인 15를 루트로 이동합니다.
```
     15
    /  \
   7   10
  /     
20
```

#### 🌾 2단계: 힙 속성 회복 (sink down)
왼쪽 자식(7) 오른쪽 자식(10) 중 더 작은 7과 비교

15 > 7 이므로 자리 바꿈

```
     7
    / \
  15   10
  /    
20
```


#### 🌾 3단계: 계속 비교
현재 노드 15의 왼쪽 자식은 20

15 < 20 이므로, 더 이상 교환하지 않고 종료

```
     7
    / \
  15   10
  /    
20
```

- 최악의 경우엔 힙의 맨 마지막 원소가 가장 큰 값을 가진 경우에요.

- 이때 연산의 횟수는 트리의 높이만큼 이루어지므로 마찬가지로 O(log n)의 시간 복잡도를 가집니다.


| |단순한 구현|힙으로 구현|
|--|--|--|
|입력|O(1)|O(log n)|
|출력|O(n)|O(log n)|


