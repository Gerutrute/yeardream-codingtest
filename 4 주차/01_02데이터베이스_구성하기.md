# ✅ 데이터베이스 구성하기

## 📌 데이터베이스 기본 구성

### 👉 테이블 (Table)

> 데이터를 행과 열로 저장하는 기본 단위

- 각 열(Column)은 특정 데이터 타입을 가짐
- 각 행(Row)은 하나의 레코드(Record) 또는 튜플(Tuple)이라고 함
- 일반적으로 엔티티(Entity)를 표현

### 👉 필드 (Field)

> 테이블의 열(Column)을 의미하며, 특정 속성을 표현

- 각 필드는 데이터 타입과 제약조건을 가질 수 있음
- 예: 이름, 나이, 주소 등

### 👉 레코드 (Record)

> 테이블의 행(Row)을 의미하며, 관련 데이터의 집합

- 하나의 개체(Entity)에 대한 모든 속성 값을 포함
- 예: 특정 사용자의 정보(이름, 나이, 주소 등)

## 📌 기본 키와 외래 키

### 👉 기본 키 (Primary Key)

> 테이블에서 각 레코드를 고유하게 식별하는 필드 또는 필드의 조합

- 다음 조건을 만족해야 함:
  - **유일성**: 중복된 값이 없어야 함
  - **Not Null**: NULL 값을 가질 수 없음
  - **최소성**: 불필요한 필드를 포함하지 않아야 함
- 예: 사용자 ID, 학번, 주민등록번호 등

### 👉 외래 키 (Foreign Key)

> 다른 테이블의 기본 키를 참조하는 필드

- 테이블 간의 관계를 설정하는 데 사용
- 참조 무결성(Referential Integrity)을 유지하는 데 중요함
- 외래 키가 참조하는 기본 키 값이 있거나, NULL이어야 함
- 예: 주문 테이블의 고객 ID는 고객 테이블의 ID를 참조

## 📌 데이터베이스 스키마

### 👉 스키마란?

> 데이터베이스의 구조와 제약조건에 관한 전반적인 명세를 기술한 것

- 테이블, 뷰, 인덱스, 저장 프로시저, 관계 등을 포함
- 개체, 속성, 관계 및 데이터 조작 시 제약조건 등을 정의

### 👉 스키마의 세 가지 관점

1. **개념적 스키마(Conceptual Schema)**
   - 전체 데이터베이스에 대한 구조적 정의
   - 일반 사용자, 프로그래머, DBA가 접근하는 데이터베이스의 전체적인 뷰

2. **내부 스키마(Internal Schema)**
   - 물리적 저장 구조를 정의
   - 데이터가 실제로 저장되는 방법을 기술

3. **외부 스키마(External Schema)**
   - 사용자 관점에서의 데이터베이스 구조
   - 사용자나 응용 프로그래머가 접근하는 데이터베이스의 논리적 구조

## 📌 ERD (Entity-Relationship Diagram)

### 👉 ERD란?

> 데이터베이스의 구조를 시각적으로 표현한 다이어그램

- 엔티티(Entity), 속성(Attribute), 관계(Relationship)를 표현
- 데이터베이스 설계 단계에서 중요한 도구

### 👉 ERD의 기본 요소

1. **엔티티(Entity)**
   - 데이터베이스에 저장하려는 객체나 개념
   - 예: 학생, 수업, 교수 등
   - 보통 사각형으로 표현

2. **속성(Attribute)**
   - 엔티티의 특성이나 성질
   - 예: 학생의 이름, 학번, 학과 등
   - 보통 타원형으로 표현

3. **관계(Relationship)**
   - 엔티티 간의 연관성
   - 예: '학생'은 '수업'을 '수강한다'
   - 보통 마름모로 표현

### 👉 ERD의 관계 표기법

**관계의 유형**:
- **1:1 (일대일)**: 각 엔티티의 인스턴스가 다른 엔티티의 인스턴스와 최대 하나씩 연결
  - 예: 사람과 주민등록증
- **1:N (일대다)**: 한 엔티티의 인스턴스가 다른 엔티티의 여러 인스턴스와 연결
  - 예: 부서와, 그에 속한 직원들
- **N:M (다대다)**: 각 엔티티의 인스턴스가 다른 엔티티의 여러 인스턴스와 연결
  - 예: 학생과 수업 (여러 학생이 여러 수업을 수강)

## 📌 데이터 모델링 과정

### 👉 개념적 모델링

> 실세계의 중요 개체를 추출하고 개체 간의 관계를 정의하는 단계

- 엔티티 추출 및 엔티티 간 관계 정의
- ERD(Entity-Relationship Diagram)의 초기 버전 생성
- 비즈니스 요구사항 중심의 높은 수준의 추상화

### 👉 논리적 모델링

> 개념적 모델을 데이터베이스에 구현 가능한 형태로 변환하는 단계

- 정규화 과정을 통한 테이블 구조 설계
- 필드와 데이터 타입 정의
- 기본 키, 외래 키 설정
- 제약조건 정의

### 👉 물리적 모델링

> 논리적 모델을 특정 DBMS에 최적화하여 구현하는 단계

- 특정 DBMS에 맞춘 테이블, 컬럼, 인덱스 생성
- 성능 최적화를 위한 설계 조정
- 저장 공간, 접근 경로 등 물리적 요소 고려

## 📌 정규화 (Normalization)

### 👉 정규화란?

> 데이터베이스의 설계를 체계화하고 이상 현상(Anomaly)을 제거하기 위한 과정

- 중복 데이터를 제거하고 데이터 무결성을 확보
- 테이블을 분해하여 효율적인 구조 구축

### 👉 이상 현상(Anomaly)의 종류

1. **삽입 이상(Insertion Anomaly)**
   - 데이터를 삽입할 때 불필요한 데이터도 함께 삽입해야 하는 문제
   - 예: 특정 학생의 첫 수강 과목을 추가할 때 과목 정보와 학생 정보를 함께 입력해야 함

2. **삭제 이상(Deletion Anomaly)**
   - 데이터 삭제 시 원치 않는 다른 데이터까지 함께 삭제되는 문제
   - 예: 학생이 특정 과목을 수강취소할 때 해당 학생의 모든 정보가 삭제됨

3. **갱신 이상(Update Anomaly)**
   - 데이터 수정 시 일부만 변경되어 일관성이 깨지는 문제
   - 예: 학생의 주소가 변경될 때 여러 레코드를 동시에 수정해야 함

### 👉 정규화 단계

1. **제1정규형(1NF)**
   - 각 컬럼이 원자값(Atomic Value)을 가짐
   - 다중값 필드를 제거

2. **제2정규형(2NF)**
   - 1NF를 만족하며, 부분 함수적 종속성을 제거
   - 기본 키의 일부에만 종속된 필드를 분리

3. **제3정규형(3NF)**
   - 2NF를 만족하며, 이행적 함수적 종속성을 제거
   - 기본 키에 의존하지 않는 필드 간의 종속성 제거

4. **Boyce-Codd 정규형(BCNF)**
   - 3NF를 만족하며, 모든 결정자가 후보 키여야 함
   - 일반적으로 3NF만 만족해도 실무에서는 충분한 경우가 많음

### 👉 역정규화(Denormalization)

> 성능 향상을 위해 정규화된 데이터베이스를 의도적으로 중복시키는 과정

- 읽기 작업이 많고 데이터 일관성보다 성능이 중요한 경우 사용
- 데이터 무결성 문제가 발생할 수 있어 신중하게 접근 필요

## 📌 인덱스 (Index)

### 👉 인덱스란?

> 데이터베이스의 검색 속도를 향상시키기 위한 자료구조

- 책의 색인과 유사한 개념
- 특정 열(Column)에 대한 검색을 빠르게 수행 가능
- B-Tree, Hash 등 다양한 알고리즘 기반으로 구현

### 👉 인덱스의 장단점

**장점**:
- 데이터 검색 속도 향상
- ORDER BY, GROUP BY 연산 속도 향상
- 조인(Join) 성능 개선

**단점**:
- 추가적인 저장공간 필요
- INSERT, UPDATE, DELETE 연산 시 성능 저하
- 인덱스 관리를 위한 추가 작업 필요

### 👉 인덱스 종류

1. **고유 인덱스(Unique Index)**
   - 중복값을 허용하지 않는 인덱스
   - 기본 키에 자동으로 생성됨

2. **비고유 인덱스(Non-unique Index)**
   - 중복값을 허용하는 인덱스
   - 자주 검색되는 컬럼에 적용

3. **단일 인덱스(Single-column Index)**
   - 하나의 컬럼에만 인덱스 적용

4. **복합 인덱스(Composite Index)**
   - 두 개 이상의 컬럼에 인덱스 적용
   - 컬럼 순서가 성능에 영향을 미침

5. **클러스터드 인덱스(Clustered Index)**
   - 실제 데이터가 인덱스 순서대로 물리적으로 정렬되어 저장
   - 테이블당 하나만 존재 가능

6. **비클러스터드 인덱스(Non-clustered Index)**
   - 데이터 순서와 인덱스 순서가 다름
   - 테이블당 여러 개 존재 가능

### 👉 인덱스 생성 시 고려사항

- WHERE 절에 자주 사용되는 컬럼에 생성
- JOIN 연산에 사용되는 컬럼에 생성
- 카디널리티(고유값 수)가 높은 컬럼에 생성
- 인덱스 수가 너무 많으면 성능 저하 가능성 있음
- 자주 변경되는 컬럼에는 신중하게 적용

## 📌 트랜잭션 (Transaction)

### 👉 트랜잭션이란?

> 데이터베이스의 상태를 변화시키는 하나의 논리적 작업 단위

- 여러 연산을 하나의 작업으로 묶어 처리
- 작업의 완전성을 보장

### 👉 트랜잭션의 ACID 속성

1. **원자성(Atomicity)**
   - 트랜잭션 내의 모든 연산이 완료되거나, 아무것도 수행되지 않아야 함
   - 부분적 실행은 허용하지 않음

2. **일관성(Consistency)**
   - 트랜잭션 실행 전과 후에 데이터베이스가 일관된 상태를 유지해야 함
   - 데이터베이스의 제약조건을 위반하지 않아야 함

3. **격리성(Isolation)**
   - 동시에 실행되는 트랜잭션들이 서로 영향을 미치지 않아야 함
   - 격리 수준(Isolation Level)에 따라 다르게 동작

4. **지속성(Durability)**
   - 성공적으로 완료된 트랜잭션의 결과는 영구적으로 반영되어야 함
   - 시스템 장애가 발생해도 데이터는 보존됨

### 👉 트랜잭션 관련 명령어

- **BEGIN** or **START TRANSACTION**: 트랜잭션 시작
- **COMMIT**: 트랜잭션 변경사항 확정
- **ROLLBACK**: 트랜잭션 변경사항 취소
- **SAVEPOINT**: 트랜잭션 내 저장점 생성
- **ROLLBACK TO**: 지정된 저장점으로 롤백

### 👉 트랜잭션 격리 수준

1. **READ UNCOMMITTED**
   - 가장 낮은 격리 수준
   - Dirty Read, Non-repeatable Read, Phantom Read 발생 가능

2. **READ COMMITTED**
   - 커밋된 데이터만 읽을 수 있음
   - Non-repeatable Read, Phantom Read 발생 가능

3. **REPEATABLE READ**
   - 트랜잭션 내에서 같은 쿼리 실행 시 항상 같은 결과 보장
   - Phantom Read 발생 가능

4. **SERIALIZABLE**
   - 가장 높은 격리 수준
   - 완전한 격리 보장, 성능 저하 발생 가능

## 📌 뷰 (View)

### 👉 뷰란?

> 하나 이상의 테이블에서 유도된 가상 테이블

- 실제 데이터는 포함하지 않고, 쿼리 정의만 저장
- 사용자에게 필요한 데이터만 제공 가능

### 👉 뷰의 장점

- **보안 강화**: 민감한 데이터를 숨기고 필요한 데이터만 제공
- **복잡한 쿼리 단순화**: 복잡한 조인을 미리 정의하여 재사용
- **데이터 추상화**: 사용자에게 논리적 데이터 구조만 제공
- **독립성 유지**: 기본 테이블 구조 변경 시에도 응용 프로그램 보호

### 👉 뷰의 종류

1. **단순 뷰(Simple View)**
   - 하나의 테이블에서 생성된 뷰
   - 경우에 따라 DML 연산(INSERT, UPDATE, DELETE) 가능

2. **복합 뷰(Complex View)**
   - 여러 테이블에서 생성된 뷰
   - 주로 조회 용도로 사용

### 👉 뷰 생성 및 관리

```sql
-- 뷰 생성
CREATE VIEW employee_details AS
SELECT e.id, e.name, d.name AS department_name
FROM employees e
JOIN departments d ON e.department_id = d.id;

-- 뷰 수정
ALTER VIEW employee_details AS
SELECT e.id, e.name, e.salary, d.name AS department_name
FROM employees e
JOIN departments d ON e.department_id = d.id;

-- 뷰 삭제
DROP VIEW employee_details;
```

